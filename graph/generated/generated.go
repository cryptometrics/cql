// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"cql/model"
	"cql/scalar"
	"errors"
	"strconv"
	"sync"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	CoinbaseProductOrderBook() CoinbaseProductOrderBookResolver
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	CoinbaseAccount struct {
		Available      func(childComplexity int) int
		Balance        func(childComplexity int) int
		Currency       func(childComplexity int) int
		Hold           func(childComplexity int) int
		ID             func(childComplexity int) int
		ProfileID      func(childComplexity int) int
		TradingEnabled func(childComplexity int) int
	}

	CoinbaseAccountHold struct {
		AccountID func(childComplexity int) int
		Amount    func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Ref       func(childComplexity int) int
		Type      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	CoinbaseAccountLedger struct {
		Amount    func(childComplexity int) int
		Balance   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Details   func(childComplexity int) int
		ID        func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	CoinbaseAccountLedgerDetails struct {
		OrderID   func(childComplexity int) int
		ProductID func(childComplexity int) int
		TradeID   func(childComplexity int) int
	}

	CoinbaseAccountTransfer struct {
		Amount      func(childComplexity int) int
		CanceledAt  func(childComplexity int) int
		CompletedAt func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Details     func(childComplexity int) int
		ID          func(childComplexity int) int
		ProcessedAt func(childComplexity int) int
		Type        func(childComplexity int) int
		UserNonce   func(childComplexity int) int
	}

	CoinbaseAccountTransferDetails struct {
		CoinbaseAccountID       func(childComplexity int) int
		CoinbasePaymentMethodID func(childComplexity int) int
		CoinbaseTransactionID   func(childComplexity int) int
	}

	CoinbaseBankCountry struct {
		Code func(childComplexity int) int
		Name func(childComplexity int) int
	}

	CoinbaseCurrency struct {
		ConvertibleTo         func(childComplexity int) int
		Details               func(childComplexity int) int
		DisplayName           func(childComplexity int) int
		ID                    func(childComplexity int) int
		MaxPrecision          func(childComplexity int) int
		MaxWithdrawalAmount   func(childComplexity int) int
		Message               func(childComplexity int) int
		MinSize               func(childComplexity int) int
		MinWithdrawalAmount   func(childComplexity int) int
		Name                  func(childComplexity int) int
		ProcessingTimeSeconds func(childComplexity int) int
		Status                func(childComplexity int) int
	}

	CoinbaseCurrencyDetails struct {
		CryptoAddressLink     func(childComplexity int) int
		CryptoTransactionLink func(childComplexity int) int
		GroupTypes            func(childComplexity int) int
		NetworkConfirmations  func(childComplexity int) int
		PushPaymentMethods    func(childComplexity int) int
		SortOrder             func(childComplexity int) int
		Symbol                func(childComplexity int) int
		Type                  func(childComplexity int) int
	}

	CoinbaseOrder struct {
		CreatedAt      func(childComplexity int) int
		ExecutedValue  func(childComplexity int) int
		FillFees       func(childComplexity int) int
		FilledSize     func(childComplexity int) int
		Funds          func(childComplexity int) int
		ID             func(childComplexity int) int
		PostOnly       func(childComplexity int) int
		Price          func(childComplexity int) int
		ProductID      func(childComplexity int) int
		STP            func(childComplexity int) int
		Settled        func(childComplexity int) int
		Side           func(childComplexity int) int
		Size           func(childComplexity int) int
		SpecifiedFunds func(childComplexity int) int
		Status         func(childComplexity int) int
		TimeInForce    func(childComplexity int) int
		Type           func(childComplexity int) int
	}

	CoinbaseProduct struct {
		BaseCurrency    func(childComplexity int) int
		BaseIncrement   func(childComplexity int) int
		BaseMaxSize     func(childComplexity int) int
		BaseMinSize     func(childComplexity int) int
		CancelOnly      func(childComplexity int) int
		DisplayName     func(childComplexity int) int
		FXStablecoin    func(childComplexity int) int
		ID              func(childComplexity int) int
		LimitOnly       func(childComplexity int) int
		MaxMarketFunds  func(childComplexity int) int
		MinMarketFunds  func(childComplexity int) int
		PostOnly        func(childComplexity int) int
		QuoteCurrency   func(childComplexity int) int
		QuoteIncrement  func(childComplexity int) int
		Status          func(childComplexity int) int
		StatusMessage   func(childComplexity int) int
		TradingDisabled func(childComplexity int) int
	}

	CoinbaseProductDailyStats struct {
		High        func(childComplexity int) int
		Last        func(childComplexity int) int
		Low         func(childComplexity int) int
		Open        func(childComplexity int) int
		Volume      func(childComplexity int) int
		Volume30Day func(childComplexity int) int
	}

	CoinbaseProductHistoricalRate struct {
		Close  func(childComplexity int) int
		High   func(childComplexity int) int
		Low    func(childComplexity int) int
		Open   func(childComplexity int) int
		Time   func(childComplexity int) int
		Volume func(childComplexity int) int
	}

	CoinbaseProductOrderBook struct {
		Asks     func(childComplexity int) int
		Bids     func(childComplexity int) int
		Sequence func(childComplexity int) int
	}

	CoinbaseProductOrderBookBidAsk struct {
		NumOrders func(childComplexity int) int
		OrderID   func(childComplexity int) int
		Price     func(childComplexity int) int
		Size      func(childComplexity int) int
	}

	CoinbaseProductTicker struct {
		Ask     func(childComplexity int) int
		Bid     func(childComplexity int) int
		Price   func(childComplexity int) int
		Size    func(childComplexity int) int
		Time    func(childComplexity int) int
		TradeID func(childComplexity int) int
		Volume  func(childComplexity int) int
	}

	CoinbaseProductTrade struct {
		Price   func(childComplexity int) int
		Side    func(childComplexity int) int
		Size    func(childComplexity int) int
		Time    func(childComplexity int) int
		TradeID func(childComplexity int) int
	}

	CoinbaseSEPADepositInformation struct {
		AccountAddress func(childComplexity int) int
		AccountName    func(childComplexity int) int
		BankAddress    func(childComplexity int) int
		BankCountry    func(childComplexity int) int
		BankName       func(childComplexity int) int
		IBAN           func(childComplexity int) int
		Reference      func(childComplexity int) int
		SWIFT          func(childComplexity int) int
	}

	CoinbaseSWIFTDepositInformation struct {
		AccountAddress func(childComplexity int) int
		AccountName    func(childComplexity int) int
		AccountNumber  func(childComplexity int) int
		BankAddress    func(childComplexity int) int
		BankCountry    func(childComplexity int) int
		BankName       func(childComplexity int) int
		Reference      func(childComplexity int) int
	}

	CoinbaseTime struct {
		Epoch func(childComplexity int) int
		ISO   func(childComplexity int) int
	}

	CoinbaseUKDepositInformation struct {
		AccountName   func(childComplexity int) int
		AccountNumber func(childComplexity int) int
		BankName      func(childComplexity int) int
		Reference     func(childComplexity int) int
		SortCode      func(childComplexity int) int
	}

	CoinbaseWallet struct {
		Active                  func(childComplexity int) int
		AvailableOnConsumer     func(childComplexity int) int
		Balance                 func(childComplexity int) int
		Currency                func(childComplexity int) int
		DestinationTagName      func(childComplexity int) int
		DestinationTagRegex     func(childComplexity int) int
		HoldBalance             func(childComplexity int) int
		HoldCurrency            func(childComplexity int) int
		ID                      func(childComplexity int) int
		Name                    func(childComplexity int) int
		Primary                 func(childComplexity int) int
		Ready                   func(childComplexity int) int
		SEPADepositInformation  func(childComplexity int) int
		SWIFTDepositInformation func(childComplexity int) int
		Type                    func(childComplexity int) int
		UKDepositInformation    func(childComplexity int) int
		WireDepositInformation  func(childComplexity int) int
	}

	CoinbaseWireDepositInformation struct {
		AccountAddress func(childComplexity int) int
		AccountName    func(childComplexity int) int
		AccountNumber  func(childComplexity int) int
		BankAddress    func(childComplexity int) int
		BankCountry    func(childComplexity int) int
		BankName       func(childComplexity int) int
		Reference      func(childComplexity int) int
		RoutingNumber  func(childComplexity int) int
	}

	Mutation struct {
		CreateCoinbaseLimitOrder func(childComplexity int, input *model.CoinbaseOrderInput) int
	}

	Query struct {
		ClinbaseClientOrder           func(childComplexity int, clientOid string) int
		CoinbaseAccount               func(childComplexity int, id string) int
		CoinbaseAccountHold           func(childComplexity int, id string, opts *model.CoinbaseAccountHoldOptions) int
		CoinbaseAccountLedger         func(childComplexity int, id string, opts *model.CoinbaseAccountLedgerOptions) int
		CoinbaseAccountTransfer       func(childComplexity int, id string, opts *model.CoinbaseAccountTransferOptions) int
		CoinbaseAccounts              func(childComplexity int, test *string) int
		CoinbaseCurrencies            func(childComplexity int, test *string) int
		CoinbaseCurrency              func(childComplexity int, id string) int
		CoinbaseOrder                 func(childComplexity int, id string) int
		CoinbaseProduct               func(childComplexity int, id string) int
		CoinbaseProductDailyStats     func(childComplexity int, id string) int
		CoinbaseProductHistoricalRate func(childComplexity int, id string, start string, end string, granularity int) int
		CoinbaseProductOrderBook      func(childComplexity int, id string, level string) int
		CoinbaseProductTicker         func(childComplexity int, id string) int
		CoinbaseProductTrade          func(childComplexity int, id string) int
		CoinbaseProducts              func(childComplexity int, test *string) int
		CoinbaseTime                  func(childComplexity int, test *string) int
		CoinbaseWallets               func(childComplexity int, filler *string) int
	}
}

type CoinbaseProductOrderBookResolver interface {
	Bids(ctx context.Context, obj *model.CoinbaseProductOrderBook) ([]*model.CoinbaseProductOrderBookBidAsk, error)
	Asks(ctx context.Context, obj *model.CoinbaseProductOrderBook) ([]*model.CoinbaseProductOrderBookBidAsk, error)
}
type MutationResolver interface {
	CreateCoinbaseLimitOrder(ctx context.Context, input *model.CoinbaseOrderInput) (*model.CoinbaseOrder, error)
}
type QueryResolver interface {
	CoinbaseAccountLedger(ctx context.Context, id string, opts *model.CoinbaseAccountLedgerOptions) ([]*model.CoinbaseAccountLedger, error)
	CoinbaseAccountHold(ctx context.Context, id string, opts *model.CoinbaseAccountHoldOptions) ([]*model.CoinbaseAccountHold, error)
	CoinbaseAccount(ctx context.Context, id string) (*model.CoinbaseAccount, error)
	CoinbaseAccounts(ctx context.Context, test *string) ([]*model.CoinbaseAccount, error)
	CoinbaseAccountTransfer(ctx context.Context, id string, opts *model.CoinbaseAccountTransferOptions) ([]*model.CoinbaseAccountTransfer, error)
	CoinbaseWallets(ctx context.Context, filler *string) ([]*model.CoinbaseWallet, error)
	ClinbaseClientOrder(ctx context.Context, clientOid string) (*model.CoinbaseOrder, error)
	CoinbaseCurrencies(ctx context.Context, test *string) ([]*model.CoinbaseCurrency, error)
	CoinbaseCurrency(ctx context.Context, id string) (*model.CoinbaseCurrency, error)
	CoinbaseOrder(ctx context.Context, id string) (*model.CoinbaseOrder, error)
	CoinbaseProducts(ctx context.Context, test *string) ([]*model.CoinbaseProduct, error)
	CoinbaseProduct(ctx context.Context, id string) (*model.CoinbaseProduct, error)
	CoinbaseProductDailyStats(ctx context.Context, id string) (*model.CoinbaseProductDailyStats, error)
	CoinbaseProductHistoricalRate(ctx context.Context, id string, start string, end string, granularity int) ([]*model.CoinbaseProductHistoricalRate, error)
	CoinbaseProductOrderBook(ctx context.Context, id string, level string) (*model.CoinbaseProductOrderBook, error)
	CoinbaseProductTicker(ctx context.Context, id string) (*model.CoinbaseProductTicker, error)
	CoinbaseProductTrade(ctx context.Context, id string) ([]*model.CoinbaseProductTrade, error)
	CoinbaseTime(ctx context.Context, test *string) (*model.CoinbaseTime, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "CoinbaseAccount.available":
		if e.complexity.CoinbaseAccount.Available == nil {
			break
		}

		return e.complexity.CoinbaseAccount.Available(childComplexity), true

	case "CoinbaseAccount.balance":
		if e.complexity.CoinbaseAccount.Balance == nil {
			break
		}

		return e.complexity.CoinbaseAccount.Balance(childComplexity), true

	case "CoinbaseAccount.currency":
		if e.complexity.CoinbaseAccount.Currency == nil {
			break
		}

		return e.complexity.CoinbaseAccount.Currency(childComplexity), true

	case "CoinbaseAccount.hold":
		if e.complexity.CoinbaseAccount.Hold == nil {
			break
		}

		return e.complexity.CoinbaseAccount.Hold(childComplexity), true

	case "CoinbaseAccount.id":
		if e.complexity.CoinbaseAccount.ID == nil {
			break
		}

		return e.complexity.CoinbaseAccount.ID(childComplexity), true

	case "CoinbaseAccount.profileID":
		if e.complexity.CoinbaseAccount.ProfileID == nil {
			break
		}

		return e.complexity.CoinbaseAccount.ProfileID(childComplexity), true

	case "CoinbaseAccount.tradingEnabled":
		if e.complexity.CoinbaseAccount.TradingEnabled == nil {
			break
		}

		return e.complexity.CoinbaseAccount.TradingEnabled(childComplexity), true

	case "CoinbaseAccountHold.accountID":
		if e.complexity.CoinbaseAccountHold.AccountID == nil {
			break
		}

		return e.complexity.CoinbaseAccountHold.AccountID(childComplexity), true

	case "CoinbaseAccountHold.amount":
		if e.complexity.CoinbaseAccountHold.Amount == nil {
			break
		}

		return e.complexity.CoinbaseAccountHold.Amount(childComplexity), true

	case "CoinbaseAccountHold.createdAt":
		if e.complexity.CoinbaseAccountHold.CreatedAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountHold.CreatedAt(childComplexity), true

	case "CoinbaseAccountHold.id":
		if e.complexity.CoinbaseAccountHold.ID == nil {
			break
		}

		return e.complexity.CoinbaseAccountHold.ID(childComplexity), true

	case "CoinbaseAccountHold.ref":
		if e.complexity.CoinbaseAccountHold.Ref == nil {
			break
		}

		return e.complexity.CoinbaseAccountHold.Ref(childComplexity), true

	case "CoinbaseAccountHold.type":
		if e.complexity.CoinbaseAccountHold.Type == nil {
			break
		}

		return e.complexity.CoinbaseAccountHold.Type(childComplexity), true

	case "CoinbaseAccountHold.updatedAt":
		if e.complexity.CoinbaseAccountHold.UpdatedAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountHold.UpdatedAt(childComplexity), true

	case "CoinbaseAccountLedger.amount":
		if e.complexity.CoinbaseAccountLedger.Amount == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedger.Amount(childComplexity), true

	case "CoinbaseAccountLedger.balance":
		if e.complexity.CoinbaseAccountLedger.Balance == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedger.Balance(childComplexity), true

	case "CoinbaseAccountLedger.createdAt":
		if e.complexity.CoinbaseAccountLedger.CreatedAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedger.CreatedAt(childComplexity), true

	case "CoinbaseAccountLedger.details":
		if e.complexity.CoinbaseAccountLedger.Details == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedger.Details(childComplexity), true

	case "CoinbaseAccountLedger.id":
		if e.complexity.CoinbaseAccountLedger.ID == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedger.ID(childComplexity), true

	case "CoinbaseAccountLedger.type":
		if e.complexity.CoinbaseAccountLedger.Type == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedger.Type(childComplexity), true

	case "CoinbaseAccountLedgerDetails.orderID":
		if e.complexity.CoinbaseAccountLedgerDetails.OrderID == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedgerDetails.OrderID(childComplexity), true

	case "CoinbaseAccountLedgerDetails.productID":
		if e.complexity.CoinbaseAccountLedgerDetails.ProductID == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedgerDetails.ProductID(childComplexity), true

	case "CoinbaseAccountLedgerDetails.tradeID":
		if e.complexity.CoinbaseAccountLedgerDetails.TradeID == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedgerDetails.TradeID(childComplexity), true

	case "CoinbaseAccountTransfer.amount":
		if e.complexity.CoinbaseAccountTransfer.Amount == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.Amount(childComplexity), true

	case "CoinbaseAccountTransfer.canceledAt":
		if e.complexity.CoinbaseAccountTransfer.CanceledAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.CanceledAt(childComplexity), true

	case "CoinbaseAccountTransfer.completedAt":
		if e.complexity.CoinbaseAccountTransfer.CompletedAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.CompletedAt(childComplexity), true

	case "CoinbaseAccountTransfer.createdAt":
		if e.complexity.CoinbaseAccountTransfer.CreatedAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.CreatedAt(childComplexity), true

	case "CoinbaseAccountTransfer.details":
		if e.complexity.CoinbaseAccountTransfer.Details == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.Details(childComplexity), true

	case "CoinbaseAccountTransfer.id":
		if e.complexity.CoinbaseAccountTransfer.ID == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.ID(childComplexity), true

	case "CoinbaseAccountTransfer.processedAt":
		if e.complexity.CoinbaseAccountTransfer.ProcessedAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.ProcessedAt(childComplexity), true

	case "CoinbaseAccountTransfer.type":
		if e.complexity.CoinbaseAccountTransfer.Type == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.Type(childComplexity), true

	case "CoinbaseAccountTransfer.userNonce":
		if e.complexity.CoinbaseAccountTransfer.UserNonce == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.UserNonce(childComplexity), true

	case "CoinbaseAccountTransferDetails.coinbaseAccountID":
		if e.complexity.CoinbaseAccountTransferDetails.CoinbaseAccountID == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransferDetails.CoinbaseAccountID(childComplexity), true

	case "CoinbaseAccountTransferDetails.coinbasePaymentMethodID":
		if e.complexity.CoinbaseAccountTransferDetails.CoinbasePaymentMethodID == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransferDetails.CoinbasePaymentMethodID(childComplexity), true

	case "CoinbaseAccountTransferDetails.coinbaseTransactionID":
		if e.complexity.CoinbaseAccountTransferDetails.CoinbaseTransactionID == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransferDetails.CoinbaseTransactionID(childComplexity), true

	case "CoinbaseBankCountry.code":
		if e.complexity.CoinbaseBankCountry.Code == nil {
			break
		}

		return e.complexity.CoinbaseBankCountry.Code(childComplexity), true

	case "CoinbaseBankCountry.name":
		if e.complexity.CoinbaseBankCountry.Name == nil {
			break
		}

		return e.complexity.CoinbaseBankCountry.Name(childComplexity), true

	case "CoinbaseCurrency.convertibleTo":
		if e.complexity.CoinbaseCurrency.ConvertibleTo == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.ConvertibleTo(childComplexity), true

	case "CoinbaseCurrency.details":
		if e.complexity.CoinbaseCurrency.Details == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.Details(childComplexity), true

	case "CoinbaseCurrency.displayName":
		if e.complexity.CoinbaseCurrency.DisplayName == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.DisplayName(childComplexity), true

	case "CoinbaseCurrency.id":
		if e.complexity.CoinbaseCurrency.ID == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.ID(childComplexity), true

	case "CoinbaseCurrency.maxPrecision":
		if e.complexity.CoinbaseCurrency.MaxPrecision == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.MaxPrecision(childComplexity), true

	case "CoinbaseCurrency.maxWithdrawalAmount":
		if e.complexity.CoinbaseCurrency.MaxWithdrawalAmount == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.MaxWithdrawalAmount(childComplexity), true

	case "CoinbaseCurrency.message":
		if e.complexity.CoinbaseCurrency.Message == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.Message(childComplexity), true

	case "CoinbaseCurrency.minSize":
		if e.complexity.CoinbaseCurrency.MinSize == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.MinSize(childComplexity), true

	case "CoinbaseCurrency.minWithdrawalAmount":
		if e.complexity.CoinbaseCurrency.MinWithdrawalAmount == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.MinWithdrawalAmount(childComplexity), true

	case "CoinbaseCurrency.name":
		if e.complexity.CoinbaseCurrency.Name == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.Name(childComplexity), true

	case "CoinbaseCurrency.processingTimeSeconds":
		if e.complexity.CoinbaseCurrency.ProcessingTimeSeconds == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.ProcessingTimeSeconds(childComplexity), true

	case "CoinbaseCurrency.status":
		if e.complexity.CoinbaseCurrency.Status == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.Status(childComplexity), true

	case "CoinbaseCurrencyDetails.cryptoAddressLink":
		if e.complexity.CoinbaseCurrencyDetails.CryptoAddressLink == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.CryptoAddressLink(childComplexity), true

	case "CoinbaseCurrencyDetails.cryptoTransactionLink":
		if e.complexity.CoinbaseCurrencyDetails.CryptoTransactionLink == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.CryptoTransactionLink(childComplexity), true

	case "CoinbaseCurrencyDetails.groupTypes":
		if e.complexity.CoinbaseCurrencyDetails.GroupTypes == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.GroupTypes(childComplexity), true

	case "CoinbaseCurrencyDetails.networkConfirmations":
		if e.complexity.CoinbaseCurrencyDetails.NetworkConfirmations == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.NetworkConfirmations(childComplexity), true

	case "CoinbaseCurrencyDetails.pushPaymentMethods":
		if e.complexity.CoinbaseCurrencyDetails.PushPaymentMethods == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.PushPaymentMethods(childComplexity), true

	case "CoinbaseCurrencyDetails.sortOrder":
		if e.complexity.CoinbaseCurrencyDetails.SortOrder == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.SortOrder(childComplexity), true

	case "CoinbaseCurrencyDetails.symbol":
		if e.complexity.CoinbaseCurrencyDetails.Symbol == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.Symbol(childComplexity), true

	case "CoinbaseCurrencyDetails.type":
		if e.complexity.CoinbaseCurrencyDetails.Type == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.Type(childComplexity), true

	case "CoinbaseOrder.createdAt":
		if e.complexity.CoinbaseOrder.CreatedAt == nil {
			break
		}

		return e.complexity.CoinbaseOrder.CreatedAt(childComplexity), true

	case "CoinbaseOrder.executedValue":
		if e.complexity.CoinbaseOrder.ExecutedValue == nil {
			break
		}

		return e.complexity.CoinbaseOrder.ExecutedValue(childComplexity), true

	case "CoinbaseOrder.fillFees":
		if e.complexity.CoinbaseOrder.FillFees == nil {
			break
		}

		return e.complexity.CoinbaseOrder.FillFees(childComplexity), true

	case "CoinbaseOrder.filledSize":
		if e.complexity.CoinbaseOrder.FilledSize == nil {
			break
		}

		return e.complexity.CoinbaseOrder.FilledSize(childComplexity), true

	case "CoinbaseOrder.funds":
		if e.complexity.CoinbaseOrder.Funds == nil {
			break
		}

		return e.complexity.CoinbaseOrder.Funds(childComplexity), true

	case "CoinbaseOrder.id":
		if e.complexity.CoinbaseOrder.ID == nil {
			break
		}

		return e.complexity.CoinbaseOrder.ID(childComplexity), true

	case "CoinbaseOrder.postOnly":
		if e.complexity.CoinbaseOrder.PostOnly == nil {
			break
		}

		return e.complexity.CoinbaseOrder.PostOnly(childComplexity), true

	case "CoinbaseOrder.price":
		if e.complexity.CoinbaseOrder.Price == nil {
			break
		}

		return e.complexity.CoinbaseOrder.Price(childComplexity), true

	case "CoinbaseOrder.productID":
		if e.complexity.CoinbaseOrder.ProductID == nil {
			break
		}

		return e.complexity.CoinbaseOrder.ProductID(childComplexity), true

	case "CoinbaseOrder.stp":
		if e.complexity.CoinbaseOrder.STP == nil {
			break
		}

		return e.complexity.CoinbaseOrder.STP(childComplexity), true

	case "CoinbaseOrder.settled":
		if e.complexity.CoinbaseOrder.Settled == nil {
			break
		}

		return e.complexity.CoinbaseOrder.Settled(childComplexity), true

	case "CoinbaseOrder.side":
		if e.complexity.CoinbaseOrder.Side == nil {
			break
		}

		return e.complexity.CoinbaseOrder.Side(childComplexity), true

	case "CoinbaseOrder.size":
		if e.complexity.CoinbaseOrder.Size == nil {
			break
		}

		return e.complexity.CoinbaseOrder.Size(childComplexity), true

	case "CoinbaseOrder.specifiedFunds":
		if e.complexity.CoinbaseOrder.SpecifiedFunds == nil {
			break
		}

		return e.complexity.CoinbaseOrder.SpecifiedFunds(childComplexity), true

	case "CoinbaseOrder.status":
		if e.complexity.CoinbaseOrder.Status == nil {
			break
		}

		return e.complexity.CoinbaseOrder.Status(childComplexity), true

	case "CoinbaseOrder.timeInForce":
		if e.complexity.CoinbaseOrder.TimeInForce == nil {
			break
		}

		return e.complexity.CoinbaseOrder.TimeInForce(childComplexity), true

	case "CoinbaseOrder.type":
		if e.complexity.CoinbaseOrder.Type == nil {
			break
		}

		return e.complexity.CoinbaseOrder.Type(childComplexity), true

	case "CoinbaseProduct.baseCurrency":
		if e.complexity.CoinbaseProduct.BaseCurrency == nil {
			break
		}

		return e.complexity.CoinbaseProduct.BaseCurrency(childComplexity), true

	case "CoinbaseProduct.baseIncrement":
		if e.complexity.CoinbaseProduct.BaseIncrement == nil {
			break
		}

		return e.complexity.CoinbaseProduct.BaseIncrement(childComplexity), true

	case "CoinbaseProduct.baseMaxSize":
		if e.complexity.CoinbaseProduct.BaseMaxSize == nil {
			break
		}

		return e.complexity.CoinbaseProduct.BaseMaxSize(childComplexity), true

	case "CoinbaseProduct.baseMinSize":
		if e.complexity.CoinbaseProduct.BaseMinSize == nil {
			break
		}

		return e.complexity.CoinbaseProduct.BaseMinSize(childComplexity), true

	case "CoinbaseProduct.cancelOnly":
		if e.complexity.CoinbaseProduct.CancelOnly == nil {
			break
		}

		return e.complexity.CoinbaseProduct.CancelOnly(childComplexity), true

	case "CoinbaseProduct.displayName":
		if e.complexity.CoinbaseProduct.DisplayName == nil {
			break
		}

		return e.complexity.CoinbaseProduct.DisplayName(childComplexity), true

	case "CoinbaseProduct.fxStablecoin":
		if e.complexity.CoinbaseProduct.FXStablecoin == nil {
			break
		}

		return e.complexity.CoinbaseProduct.FXStablecoin(childComplexity), true

	case "CoinbaseProduct.id":
		if e.complexity.CoinbaseProduct.ID == nil {
			break
		}

		return e.complexity.CoinbaseProduct.ID(childComplexity), true

	case "CoinbaseProduct.limitOnly":
		if e.complexity.CoinbaseProduct.LimitOnly == nil {
			break
		}

		return e.complexity.CoinbaseProduct.LimitOnly(childComplexity), true

	case "CoinbaseProduct.maxMarketFunds":
		if e.complexity.CoinbaseProduct.MaxMarketFunds == nil {
			break
		}

		return e.complexity.CoinbaseProduct.MaxMarketFunds(childComplexity), true

	case "CoinbaseProduct.minMarketFunds":
		if e.complexity.CoinbaseProduct.MinMarketFunds == nil {
			break
		}

		return e.complexity.CoinbaseProduct.MinMarketFunds(childComplexity), true

	case "CoinbaseProduct.postOnly":
		if e.complexity.CoinbaseProduct.PostOnly == nil {
			break
		}

		return e.complexity.CoinbaseProduct.PostOnly(childComplexity), true

	case "CoinbaseProduct.quoteCurrency":
		if e.complexity.CoinbaseProduct.QuoteCurrency == nil {
			break
		}

		return e.complexity.CoinbaseProduct.QuoteCurrency(childComplexity), true

	case "CoinbaseProduct.quoteIncrement":
		if e.complexity.CoinbaseProduct.QuoteIncrement == nil {
			break
		}

		return e.complexity.CoinbaseProduct.QuoteIncrement(childComplexity), true

	case "CoinbaseProduct.status":
		if e.complexity.CoinbaseProduct.Status == nil {
			break
		}

		return e.complexity.CoinbaseProduct.Status(childComplexity), true

	case "CoinbaseProduct.statusMessage":
		if e.complexity.CoinbaseProduct.StatusMessage == nil {
			break
		}

		return e.complexity.CoinbaseProduct.StatusMessage(childComplexity), true

	case "CoinbaseProduct.tradingDisabled":
		if e.complexity.CoinbaseProduct.TradingDisabled == nil {
			break
		}

		return e.complexity.CoinbaseProduct.TradingDisabled(childComplexity), true

	case "CoinbaseProductDailyStats.high":
		if e.complexity.CoinbaseProductDailyStats.High == nil {
			break
		}

		return e.complexity.CoinbaseProductDailyStats.High(childComplexity), true

	case "CoinbaseProductDailyStats.last":
		if e.complexity.CoinbaseProductDailyStats.Last == nil {
			break
		}

		return e.complexity.CoinbaseProductDailyStats.Last(childComplexity), true

	case "CoinbaseProductDailyStats.low":
		if e.complexity.CoinbaseProductDailyStats.Low == nil {
			break
		}

		return e.complexity.CoinbaseProductDailyStats.Low(childComplexity), true

	case "CoinbaseProductDailyStats.open":
		if e.complexity.CoinbaseProductDailyStats.Open == nil {
			break
		}

		return e.complexity.CoinbaseProductDailyStats.Open(childComplexity), true

	case "CoinbaseProductDailyStats.volume":
		if e.complexity.CoinbaseProductDailyStats.Volume == nil {
			break
		}

		return e.complexity.CoinbaseProductDailyStats.Volume(childComplexity), true

	case "CoinbaseProductDailyStats.volume30Day":
		if e.complexity.CoinbaseProductDailyStats.Volume30Day == nil {
			break
		}

		return e.complexity.CoinbaseProductDailyStats.Volume30Day(childComplexity), true

	case "CoinbaseProductHistoricalRate.close":
		if e.complexity.CoinbaseProductHistoricalRate.Close == nil {
			break
		}

		return e.complexity.CoinbaseProductHistoricalRate.Close(childComplexity), true

	case "CoinbaseProductHistoricalRate.high":
		if e.complexity.CoinbaseProductHistoricalRate.High == nil {
			break
		}

		return e.complexity.CoinbaseProductHistoricalRate.High(childComplexity), true

	case "CoinbaseProductHistoricalRate.low":
		if e.complexity.CoinbaseProductHistoricalRate.Low == nil {
			break
		}

		return e.complexity.CoinbaseProductHistoricalRate.Low(childComplexity), true

	case "CoinbaseProductHistoricalRate.open":
		if e.complexity.CoinbaseProductHistoricalRate.Open == nil {
			break
		}

		return e.complexity.CoinbaseProductHistoricalRate.Open(childComplexity), true

	case "CoinbaseProductHistoricalRate.time":
		if e.complexity.CoinbaseProductHistoricalRate.Time == nil {
			break
		}

		return e.complexity.CoinbaseProductHistoricalRate.Time(childComplexity), true

	case "CoinbaseProductHistoricalRate.volume":
		if e.complexity.CoinbaseProductHistoricalRate.Volume == nil {
			break
		}

		return e.complexity.CoinbaseProductHistoricalRate.Volume(childComplexity), true

	case "CoinbaseProductOrderBook.asks":
		if e.complexity.CoinbaseProductOrderBook.Asks == nil {
			break
		}

		return e.complexity.CoinbaseProductOrderBook.Asks(childComplexity), true

	case "CoinbaseProductOrderBook.bids":
		if e.complexity.CoinbaseProductOrderBook.Bids == nil {
			break
		}

		return e.complexity.CoinbaseProductOrderBook.Bids(childComplexity), true

	case "CoinbaseProductOrderBook.sequence":
		if e.complexity.CoinbaseProductOrderBook.Sequence == nil {
			break
		}

		return e.complexity.CoinbaseProductOrderBook.Sequence(childComplexity), true

	case "CoinbaseProductOrderBookBidAsk.numOrders":
		if e.complexity.CoinbaseProductOrderBookBidAsk.NumOrders == nil {
			break
		}

		return e.complexity.CoinbaseProductOrderBookBidAsk.NumOrders(childComplexity), true

	case "CoinbaseProductOrderBookBidAsk.orderID":
		if e.complexity.CoinbaseProductOrderBookBidAsk.OrderID == nil {
			break
		}

		return e.complexity.CoinbaseProductOrderBookBidAsk.OrderID(childComplexity), true

	case "CoinbaseProductOrderBookBidAsk.price":
		if e.complexity.CoinbaseProductOrderBookBidAsk.Price == nil {
			break
		}

		return e.complexity.CoinbaseProductOrderBookBidAsk.Price(childComplexity), true

	case "CoinbaseProductOrderBookBidAsk.size":
		if e.complexity.CoinbaseProductOrderBookBidAsk.Size == nil {
			break
		}

		return e.complexity.CoinbaseProductOrderBookBidAsk.Size(childComplexity), true

	case "CoinbaseProductTicker.ask":
		if e.complexity.CoinbaseProductTicker.Ask == nil {
			break
		}

		return e.complexity.CoinbaseProductTicker.Ask(childComplexity), true

	case "CoinbaseProductTicker.bid":
		if e.complexity.CoinbaseProductTicker.Bid == nil {
			break
		}

		return e.complexity.CoinbaseProductTicker.Bid(childComplexity), true

	case "CoinbaseProductTicker.price":
		if e.complexity.CoinbaseProductTicker.Price == nil {
			break
		}

		return e.complexity.CoinbaseProductTicker.Price(childComplexity), true

	case "CoinbaseProductTicker.size":
		if e.complexity.CoinbaseProductTicker.Size == nil {
			break
		}

		return e.complexity.CoinbaseProductTicker.Size(childComplexity), true

	case "CoinbaseProductTicker.time":
		if e.complexity.CoinbaseProductTicker.Time == nil {
			break
		}

		return e.complexity.CoinbaseProductTicker.Time(childComplexity), true

	case "CoinbaseProductTicker.tradeID":
		if e.complexity.CoinbaseProductTicker.TradeID == nil {
			break
		}

		return e.complexity.CoinbaseProductTicker.TradeID(childComplexity), true

	case "CoinbaseProductTicker.volume":
		if e.complexity.CoinbaseProductTicker.Volume == nil {
			break
		}

		return e.complexity.CoinbaseProductTicker.Volume(childComplexity), true

	case "CoinbaseProductTrade.price":
		if e.complexity.CoinbaseProductTrade.Price == nil {
			break
		}

		return e.complexity.CoinbaseProductTrade.Price(childComplexity), true

	case "CoinbaseProductTrade.side":
		if e.complexity.CoinbaseProductTrade.Side == nil {
			break
		}

		return e.complexity.CoinbaseProductTrade.Side(childComplexity), true

	case "CoinbaseProductTrade.size":
		if e.complexity.CoinbaseProductTrade.Size == nil {
			break
		}

		return e.complexity.CoinbaseProductTrade.Size(childComplexity), true

	case "CoinbaseProductTrade.time":
		if e.complexity.CoinbaseProductTrade.Time == nil {
			break
		}

		return e.complexity.CoinbaseProductTrade.Time(childComplexity), true

	case "CoinbaseProductTrade.tradeID":
		if e.complexity.CoinbaseProductTrade.TradeID == nil {
			break
		}

		return e.complexity.CoinbaseProductTrade.TradeID(childComplexity), true

	case "CoinbaseSEPADepositInformation.accountAddress":
		if e.complexity.CoinbaseSEPADepositInformation.AccountAddress == nil {
			break
		}

		return e.complexity.CoinbaseSEPADepositInformation.AccountAddress(childComplexity), true

	case "CoinbaseSEPADepositInformation.accountName":
		if e.complexity.CoinbaseSEPADepositInformation.AccountName == nil {
			break
		}

		return e.complexity.CoinbaseSEPADepositInformation.AccountName(childComplexity), true

	case "CoinbaseSEPADepositInformation.bankAddress":
		if e.complexity.CoinbaseSEPADepositInformation.BankAddress == nil {
			break
		}

		return e.complexity.CoinbaseSEPADepositInformation.BankAddress(childComplexity), true

	case "CoinbaseSEPADepositInformation.bankCountry":
		if e.complexity.CoinbaseSEPADepositInformation.BankCountry == nil {
			break
		}

		return e.complexity.CoinbaseSEPADepositInformation.BankCountry(childComplexity), true

	case "CoinbaseSEPADepositInformation.bankName":
		if e.complexity.CoinbaseSEPADepositInformation.BankName == nil {
			break
		}

		return e.complexity.CoinbaseSEPADepositInformation.BankName(childComplexity), true

	case "CoinbaseSEPADepositInformation.iban":
		if e.complexity.CoinbaseSEPADepositInformation.IBAN == nil {
			break
		}

		return e.complexity.CoinbaseSEPADepositInformation.IBAN(childComplexity), true

	case "CoinbaseSEPADepositInformation.reference":
		if e.complexity.CoinbaseSEPADepositInformation.Reference == nil {
			break
		}

		return e.complexity.CoinbaseSEPADepositInformation.Reference(childComplexity), true

	case "CoinbaseSEPADepositInformation.swift":
		if e.complexity.CoinbaseSEPADepositInformation.SWIFT == nil {
			break
		}

		return e.complexity.CoinbaseSEPADepositInformation.SWIFT(childComplexity), true

	case "CoinbaseSWIFTDepositInformation.accountAddress":
		if e.complexity.CoinbaseSWIFTDepositInformation.AccountAddress == nil {
			break
		}

		return e.complexity.CoinbaseSWIFTDepositInformation.AccountAddress(childComplexity), true

	case "CoinbaseSWIFTDepositInformation.accountName":
		if e.complexity.CoinbaseSWIFTDepositInformation.AccountName == nil {
			break
		}

		return e.complexity.CoinbaseSWIFTDepositInformation.AccountName(childComplexity), true

	case "CoinbaseSWIFTDepositInformation.accountNumber":
		if e.complexity.CoinbaseSWIFTDepositInformation.AccountNumber == nil {
			break
		}

		return e.complexity.CoinbaseSWIFTDepositInformation.AccountNumber(childComplexity), true

	case "CoinbaseSWIFTDepositInformation.bankAddress":
		if e.complexity.CoinbaseSWIFTDepositInformation.BankAddress == nil {
			break
		}

		return e.complexity.CoinbaseSWIFTDepositInformation.BankAddress(childComplexity), true

	case "CoinbaseSWIFTDepositInformation.bankCountry":
		if e.complexity.CoinbaseSWIFTDepositInformation.BankCountry == nil {
			break
		}

		return e.complexity.CoinbaseSWIFTDepositInformation.BankCountry(childComplexity), true

	case "CoinbaseSWIFTDepositInformation.bankName":
		if e.complexity.CoinbaseSWIFTDepositInformation.BankName == nil {
			break
		}

		return e.complexity.CoinbaseSWIFTDepositInformation.BankName(childComplexity), true

	case "CoinbaseSWIFTDepositInformation.reference":
		if e.complexity.CoinbaseSWIFTDepositInformation.Reference == nil {
			break
		}

		return e.complexity.CoinbaseSWIFTDepositInformation.Reference(childComplexity), true

	case "CoinbaseTime.epoch":
		if e.complexity.CoinbaseTime.Epoch == nil {
			break
		}

		return e.complexity.CoinbaseTime.Epoch(childComplexity), true

	case "CoinbaseTime.iso":
		if e.complexity.CoinbaseTime.ISO == nil {
			break
		}

		return e.complexity.CoinbaseTime.ISO(childComplexity), true

	case "CoinbaseUKDepositInformation.accountName":
		if e.complexity.CoinbaseUKDepositInformation.AccountName == nil {
			break
		}

		return e.complexity.CoinbaseUKDepositInformation.AccountName(childComplexity), true

	case "CoinbaseUKDepositInformation.accountNumber":
		if e.complexity.CoinbaseUKDepositInformation.AccountNumber == nil {
			break
		}

		return e.complexity.CoinbaseUKDepositInformation.AccountNumber(childComplexity), true

	case "CoinbaseUKDepositInformation.bankName":
		if e.complexity.CoinbaseUKDepositInformation.BankName == nil {
			break
		}

		return e.complexity.CoinbaseUKDepositInformation.BankName(childComplexity), true

	case "CoinbaseUKDepositInformation.reference":
		if e.complexity.CoinbaseUKDepositInformation.Reference == nil {
			break
		}

		return e.complexity.CoinbaseUKDepositInformation.Reference(childComplexity), true

	case "CoinbaseUKDepositInformation.sortCode":
		if e.complexity.CoinbaseUKDepositInformation.SortCode == nil {
			break
		}

		return e.complexity.CoinbaseUKDepositInformation.SortCode(childComplexity), true

	case "CoinbaseWallet.active":
		if e.complexity.CoinbaseWallet.Active == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Active(childComplexity), true

	case "CoinbaseWallet.availableOnConsumer":
		if e.complexity.CoinbaseWallet.AvailableOnConsumer == nil {
			break
		}

		return e.complexity.CoinbaseWallet.AvailableOnConsumer(childComplexity), true

	case "CoinbaseWallet.balance":
		if e.complexity.CoinbaseWallet.Balance == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Balance(childComplexity), true

	case "CoinbaseWallet.currency":
		if e.complexity.CoinbaseWallet.Currency == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Currency(childComplexity), true

	case "CoinbaseWallet.destinationTagName":
		if e.complexity.CoinbaseWallet.DestinationTagName == nil {
			break
		}

		return e.complexity.CoinbaseWallet.DestinationTagName(childComplexity), true

	case "CoinbaseWallet.destinationTagRegex":
		if e.complexity.CoinbaseWallet.DestinationTagRegex == nil {
			break
		}

		return e.complexity.CoinbaseWallet.DestinationTagRegex(childComplexity), true

	case "CoinbaseWallet.holdBalance":
		if e.complexity.CoinbaseWallet.HoldBalance == nil {
			break
		}

		return e.complexity.CoinbaseWallet.HoldBalance(childComplexity), true

	case "CoinbaseWallet.holdCurrency":
		if e.complexity.CoinbaseWallet.HoldCurrency == nil {
			break
		}

		return e.complexity.CoinbaseWallet.HoldCurrency(childComplexity), true

	case "CoinbaseWallet.id":
		if e.complexity.CoinbaseWallet.ID == nil {
			break
		}

		return e.complexity.CoinbaseWallet.ID(childComplexity), true

	case "CoinbaseWallet.name":
		if e.complexity.CoinbaseWallet.Name == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Name(childComplexity), true

	case "CoinbaseWallet.primary":
		if e.complexity.CoinbaseWallet.Primary == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Primary(childComplexity), true

	case "CoinbaseWallet.ready":
		if e.complexity.CoinbaseWallet.Ready == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Ready(childComplexity), true

	case "CoinbaseWallet.sepaDepositInformation":
		if e.complexity.CoinbaseWallet.SEPADepositInformation == nil {
			break
		}

		return e.complexity.CoinbaseWallet.SEPADepositInformation(childComplexity), true

	case "CoinbaseWallet.swiftDepositInformation":
		if e.complexity.CoinbaseWallet.SWIFTDepositInformation == nil {
			break
		}

		return e.complexity.CoinbaseWallet.SWIFTDepositInformation(childComplexity), true

	case "CoinbaseWallet.type":
		if e.complexity.CoinbaseWallet.Type == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Type(childComplexity), true

	case "CoinbaseWallet.ukDepositInformation":
		if e.complexity.CoinbaseWallet.UKDepositInformation == nil {
			break
		}

		return e.complexity.CoinbaseWallet.UKDepositInformation(childComplexity), true

	case "CoinbaseWallet.wireDepositInformation":
		if e.complexity.CoinbaseWallet.WireDepositInformation == nil {
			break
		}

		return e.complexity.CoinbaseWallet.WireDepositInformation(childComplexity), true

	case "CoinbaseWireDepositInformation.accountAddress":
		if e.complexity.CoinbaseWireDepositInformation.AccountAddress == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.AccountAddress(childComplexity), true

	case "CoinbaseWireDepositInformation.accountName":
		if e.complexity.CoinbaseWireDepositInformation.AccountName == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.AccountName(childComplexity), true

	case "CoinbaseWireDepositInformation.accountNumber":
		if e.complexity.CoinbaseWireDepositInformation.AccountNumber == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.AccountNumber(childComplexity), true

	case "CoinbaseWireDepositInformation.bankAddress":
		if e.complexity.CoinbaseWireDepositInformation.BankAddress == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.BankAddress(childComplexity), true

	case "CoinbaseWireDepositInformation.bankCountry":
		if e.complexity.CoinbaseWireDepositInformation.BankCountry == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.BankCountry(childComplexity), true

	case "CoinbaseWireDepositInformation.bankName":
		if e.complexity.CoinbaseWireDepositInformation.BankName == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.BankName(childComplexity), true

	case "CoinbaseWireDepositInformation.reference":
		if e.complexity.CoinbaseWireDepositInformation.Reference == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.Reference(childComplexity), true

	case "CoinbaseWireDepositInformation.routingNumber":
		if e.complexity.CoinbaseWireDepositInformation.RoutingNumber == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.RoutingNumber(childComplexity), true

	case "Mutation.createCoinbaseLimitOrder":
		if e.complexity.Mutation.CreateCoinbaseLimitOrder == nil {
			break
		}

		args, err := ec.field_Mutation_createCoinbaseLimitOrder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCoinbaseLimitOrder(childComplexity, args["input"].(*model.CoinbaseOrderInput)), true

	case "Query.clinbaseClientOrder":
		if e.complexity.Query.ClinbaseClientOrder == nil {
			break
		}

		args, err := ec.field_Query_clinbaseClientOrder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ClinbaseClientOrder(childComplexity, args["clientOID"].(string)), true

	case "Query.coinbaseAccount":
		if e.complexity.Query.CoinbaseAccount == nil {
			break
		}

		args, err := ec.field_Query_coinbaseAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseAccount(childComplexity, args["id"].(string)), true

	case "Query.coinbaseAccountHold":
		if e.complexity.Query.CoinbaseAccountHold == nil {
			break
		}

		args, err := ec.field_Query_coinbaseAccountHold_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseAccountHold(childComplexity, args["id"].(string), args["opts"].(*model.CoinbaseAccountHoldOptions)), true

	case "Query.coinbaseAccountLedger":
		if e.complexity.Query.CoinbaseAccountLedger == nil {
			break
		}

		args, err := ec.field_Query_coinbaseAccountLedger_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseAccountLedger(childComplexity, args["id"].(string), args["opts"].(*model.CoinbaseAccountLedgerOptions)), true

	case "Query.coinbaseAccountTransfer":
		if e.complexity.Query.CoinbaseAccountTransfer == nil {
			break
		}

		args, err := ec.field_Query_coinbaseAccountTransfer_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseAccountTransfer(childComplexity, args["id"].(string), args["opts"].(*model.CoinbaseAccountTransferOptions)), true

	case "Query.coinbaseAccounts":
		if e.complexity.Query.CoinbaseAccounts == nil {
			break
		}

		args, err := ec.field_Query_coinbaseAccounts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseAccounts(childComplexity, args["test"].(*string)), true

	case "Query.coinbaseCurrencies":
		if e.complexity.Query.CoinbaseCurrencies == nil {
			break
		}

		args, err := ec.field_Query_coinbaseCurrencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseCurrencies(childComplexity, args["test"].(*string)), true

	case "Query.coinbaseCurrency":
		if e.complexity.Query.CoinbaseCurrency == nil {
			break
		}

		args, err := ec.field_Query_coinbaseCurrency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseCurrency(childComplexity, args["id"].(string)), true

	case "Query.coinbaseOrder":
		if e.complexity.Query.CoinbaseOrder == nil {
			break
		}

		args, err := ec.field_Query_coinbaseOrder_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseOrder(childComplexity, args["id"].(string)), true

	case "Query.coinbaseProduct":
		if e.complexity.Query.CoinbaseProduct == nil {
			break
		}

		args, err := ec.field_Query_coinbaseProduct_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseProduct(childComplexity, args["id"].(string)), true

	case "Query.coinbaseProductDailyStats":
		if e.complexity.Query.CoinbaseProductDailyStats == nil {
			break
		}

		args, err := ec.field_Query_coinbaseProductDailyStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseProductDailyStats(childComplexity, args["id"].(string)), true

	case "Query.coinbaseProductHistoricalRate":
		if e.complexity.Query.CoinbaseProductHistoricalRate == nil {
			break
		}

		args, err := ec.field_Query_coinbaseProductHistoricalRate_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseProductHistoricalRate(childComplexity, args["id"].(string), args["start"].(string), args["end"].(string), args["granularity"].(int)), true

	case "Query.coinbaseProductOrderBook":
		if e.complexity.Query.CoinbaseProductOrderBook == nil {
			break
		}

		args, err := ec.field_Query_coinbaseProductOrderBook_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseProductOrderBook(childComplexity, args["id"].(string), args["level"].(string)), true

	case "Query.coinbaseProductTicker":
		if e.complexity.Query.CoinbaseProductTicker == nil {
			break
		}

		args, err := ec.field_Query_coinbaseProductTicker_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseProductTicker(childComplexity, args["id"].(string)), true

	case "Query.coinbaseProductTrade":
		if e.complexity.Query.CoinbaseProductTrade == nil {
			break
		}

		args, err := ec.field_Query_coinbaseProductTrade_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseProductTrade(childComplexity, args["id"].(string)), true

	case "Query.coinbaseProducts":
		if e.complexity.Query.CoinbaseProducts == nil {
			break
		}

		args, err := ec.field_Query_coinbaseProducts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseProducts(childComplexity, args["test"].(*string)), true

	case "Query.coinbaseTime":
		if e.complexity.Query.CoinbaseTime == nil {
			break
		}

		args, err := ec.field_Query_coinbaseTime_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseTime(childComplexity, args["test"].(*string)), true

	case "Query.coinbaseWallets":
		if e.complexity.Query.CoinbaseWallets == nil {
			break
		}

		args, err := ec.field_Query_coinbaseWallets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseWallets(childComplexity, args["_filler_"].(*string)), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "graph/schema/coinbase_account.graphqls", Input: `"""
CoinbaseAccount encapsulates information for a coinbase account
"""
type CoinbaseAccount {
  id: String
  currency: String
  balance: Float
  available: Float
  hold: Float
  profileID: String
  tradingEnabled: Boolean
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_account_hold.graphqls", Input: `"""
CoinbaseAccountHold represents a hold of an account that belong to the same
profile as the API key. Holds are placed on an account for any active orders
or pending withdraw requests. As an order is filled, the hold amount is
updated. If an order is canceled, any remaining hold is removed. For a
withdraw, once it is completed, the hold is removed
"""
type CoinbaseAccountHold {
  id: String
  accountID: String
  createdAt: Time
  updatedAt: Time
  amount: Float
  type: String
  ref: String
}

input CoinbaseAccountHoldOptions {
  """
  Pagination parameter that requires a positive integer. If set, returns a
  list of holds before the specified integer.
  """
  before: String

  """
  Pagination parameter that requires a positive integer. If set, returns a
  list of holds after the specified integer.
  """
  after: String

  """
  Number of results per request. Maximum 1000. (default 1000)
  """
  limit: Int
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_account_ledger.graphqls", Input: `"""
CoinbaseAccountLedgerDetails are the details for account history
"""
type CoinbaseAccountLedgerDetails {
  orderID: String
  tradeID: String
  productID: String
}

"""
CoinbaseAccountHistory encapsulates data for account activity of the API
key's profile. Account activity either increases or decreases your account
balance. Items are paginated and sorted latest first. See the Pagination
section for retrieving additional entries after the first page.
"""
type CoinbaseAccountLedger {
  id: String
  createdAt: Time
  amount: Float
  balance: Float
  type: EntryType
  details: CoinbaseAccountLedgerDetails
}

input CoinbaseAccountLedgerOptions {
  """
  Parameter requires a positive integer. If set, returns ledger entries before
  the specified integer.
  """
  before: String

  """
  Parameter requires a positive integer. If set, returns ledger entries after
  the specified integer.
  """
  after: String

  """
  If set, returns ledger entries created after the start_date timestamp,
  sorted by newest creation date. When combined with end_date, returns ledger
  entries in the specified time range.
  """
  startDate: String

  """
  If set, returns ledger entries created before the end_date timestamp, sorted
  by newest creation date.
  """
  endDate: String

  """
  Number of results per request. Maximum 1000. (default 1000)
  """
  limit: Int

  profileID: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_account_transfer.graphqls", Input: `type CoinbaseAccountTransferDetails {
  coinbaseAccountID: String
  coinbaseTransactionID: String
  coinbasePaymentMethodID: String
}

"""
CoinbaseAccountTransfer lists past withdrawals and deposits for an account.
"""
type CoinbaseAccountTransfer {
  id: String
  type: String
  createdAt: Time
  completedAt: Time
  canceledAt: Time
  processedAt: Time
  amount: Float
  userNonce: String
  details: CoinbaseAccountTransferDetails
}

input CoinbaseAccountTransferOptions {
  """
  Used for pagination. Sets start cursor to before date.
  """
  before: String

  """
  Used for pagination. Sets end cursor to after date.
  """
  after: String

  """
  Limit on number of results to return.
  """
  limit: Int

  type: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_currency.graphqls", Input: `"""
CoinbaseCurrency holds currency data from the coinbase API. Currency codes will
conform to the ISO 4217 standard where possible. Currencies which have or had no
representation in ISO 4217 may use a custom code.
"""
type CoinbaseCurrency {
  """
  id is the code coinbase uses to recognize an asset, e.g. BTC, ETH, etc
  """
  id: String!

  """
  name is the full name associated with the id/code
  """
  name: String!

  minSize: Float
  status: String
  message: String
  maxPrecision: Float
  convertibleTo: [String]
  details: CoinbaseCurrencyDetails
  displayName: String
  processingTimeSeconds: Int
  minWithdrawalAmount: Int
  maxWithdrawalAmount: Int
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_currency_details.graphqls", Input: `type CoinbaseCurrencyDetails {
  type: String
  symbol: String
  networkConfirmations: Int
  sortOrder: Int
  cryptoAddressLink: String
  cryptoTransactionLink: String
  pushPaymentMethods: [String]
  groupTypes: [String]
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_order.graphqls", Input: `"""
CoinbaseOrder is the response to an order request in the coinbase API
"""
type CoinbaseOrder {
  id: String
  price: Float
  size: Float
  productID: String
  side: OrderSide
  stp: OrderSTP
  type: OrderType
  timeInForce: TimeInForce
  postOnly: Boolean
  createdAt: Time
  fillFees: Float
  filledSize: Float
  executedValue: Float
  status: String
  settled: Boolean
  funds: Float
  specifiedFunds: Float
}

input CoinbaseOrderInput {
  """
  buy or sell
  """
  side: OrderSide!

  """
  A valid product id, these are of the form {baseCurrency}-{quoteCurrency}, e.g
  BTC-USD.  The product_id must match a valid product. The products list is
  available via the /products endpoint.
  """
  productID: String!

  """
  [optional] Order ID selected by you to identify your order.  The optional
  client_oid field must be a UUID generated by your trading application. This
  field value will be broadcast in the public feed for received messages. You
  can use this field to identify your orders in the public feed.  The client_oid
  is different than the server-assigned order id. If you are consuming the
  public feed and see a received message with your client_oid, you should record
  the server-assigned order_id as it will be used for future order status
  updates. The client_oid will NOT be used after the received message is sent.
  The server-assigned order id is also returned as the id field to this HTTP
  POST request.
  """
  clientOID: String

  """
  [optional] Self-trade prevention flag.  Self-trading is not allowed on
  Coinbase Pro. Two orders from the same user will not be allowed to match with
  one another. To change the self-trade behavior, specify the stp flag.
  """
  stp: OrderSTP

  """
  Either loss or entry. Requires stop_price to be defined.
  """
  stop: OrderStop

  """
  [optional] Only if stop is defined. Sets trigger price for stop order.
  """
  stopPrice: String

  """
  The price must be specified in quote_increment product units. The quote
  increment is the smallest unit of price. For example, the BTC-USD product has
  a quote increment of 0.01 or 1 penny. Prices less than 1 penny will not be
  accepted, and no fractional penny prices will be accepted. Not required for
  market orders.
  """
  price: Float!

  """
  The size must be greater than the base_min_size for the product and no larger
  than the base_max_size. The size can be in incremented in units of
  base_increment. size indicates the amount of BTC (or base currency) to buy or
  sell.
  """
  size: Float!

  """
  [optional] GTC, GTT, IOC, or FOK (default is GTC).  Time in force policies
  provide guarantees about the lifetime of an order. There are four policies:
  good till canceled GTC, good till time GTT, immediate or cancel IOC, and fill
  or kill FOK.
  """
  timeInForce: TimeInForce

  """
  [optional]* min, hour, day
  """
  cancelAfter: OrderCancelTime

  """
  [optional]** Post only flag.  The post-only flag indicates that the order
  should only make liquidity. If any part of the order results in taking
  liquidity, the order will be rejected and no part of it will execute.
  """
  postOnly: Boolean
}

input CoinbaseOrderQueryParameters {
  """
  Limit list of orders to these statuses. Passing all returns orders of all
  statuses. Valid statuses: 'open', 'pending', 'rejected', 'done', 'active'.

  Default: 	['open', 'pending', 'active']
  """
  statuses: [String]

  """
  Only list orders for a specific product
  """
  products: [String]

  """
  Limit list of orders to after this start_date
  """
  startDate: String

  """
  Limit list of orders to before this end_date
  """
  endDate: String

  """
  Pagination parameter that requires a positive integer. If set, returns a list
  of orders before the specified integer.
  """
  before: Int

  """
  Pagination parameter that requires a positive integer. If set, returns a list
  of orders after the specified integer.
  """
  after: Int

  """
  Number of results per request. Maximum 1000. (default 1000)
  """
  limit: Int
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_product.graphqls", Input: `"""
CoinbaseProduct returns the market data for a specific currency pair. Only a
maximum of one of trading_disabled, cancel_only, post_only, limit_only can be
true at once. If none are true, the product is trading normally.
"""
type CoinbaseProduct {
  """
  id specifies the product as a pair on the coinbase app in the form
  {baseCurrency}-{quoteCurrency}, e.g. BTC-USD, ETH-BTC, etc
  """
  id: String

  """
  displayName is a human-readable format of id i.e. {baseCurrency} per
  {quoteCurrency}
  """
  displayName: String

  """
  baseCurrency is the currency we are measuring in terms of the quote currency
  """
  baseCurrency: String

  """
  quoteCurrency is the currency we are using to compare with the baseCurrency
  """
  quoteCurrency: String

  """
  baseIncrement specifies the minimum increment for the base_currency
  """
  baseIncrement: Float

  """
  quoteIncrement field specifies the min order price as well as the price
  increment.  The order price must be a multiple of this increment (i.e. if the
  increment is 0.01, order prices of 0.001 or 0.021 would be rejected
  """
  quoteIncrement: Float

  """
  baseMinSize defines the min order size
  """
  baseMinSize: Float

  """
  baseMaxSize defines the max order siz
  """
  baseMaxSize: Float

  """
  minMarketFunds defines the min funds allowed in a market order
  """
  minMarketFunds: Float

  """
  maxMarketFunds defines the max funds allowed in a market orde
  """
  maxMarketFunds: Float

  """
  status reflects the condition of the product on coinbase, whether it's online,
  etc
  """
  status: String

  """
  statusMessage provides any extra information regarding the status if
  available
  """
  statusMessage: String

  """
  cancelOnly indicates whether this product only accepts cancel requests for
  orders
  """
  cancelOnly: Boolean

  """
  limitOnly indicates whether this product only accepts limit orders
  """
  limitOnly: Boolean

  """
  postOnly indicates whether only maker orders can be placed. No orders will be
  matched when post_only mode is active
  """
  postOnly: Boolean

  """
  tradingDisabled indicates whether trading is currently restricted on this
  product, this includes whether both new orders and order cancelations are
  restricted.
  """
  tradingDisabled: Boolean

  """
  fxStablecoin indicates whether the currency pair is a Stable Pair
  """
  fxStablecoin: Boolean
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_product_daily_stats.graphqls", Input: `"""
CoinbaseProductDailyStats encapsulates 24 hr stats for the product
"""
type CoinbaseProductDailyStats {
  """
  open is in quote currency units; product={base}-{quote}
  """
  open: Float

  """
  high is in quote currency units; product={base}-{quote}
  """
  high: Float
  low: Float

  """
  Volume is in base currency units; product={base}-{quote}
  """
  volume: Float
  last: Float
  volume30Day: Float
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_product_historical_rate.graphqls", Input: `"""
CoinbaseProductHistoricalRate are historic rates for a product. Rates are
returned in grouped buckets based on requested granularity.

Historical rate data may be incomplete. No data is published for intervals
where there are no ticks.

Historical rates should not be polled frequently. If you need real-time
information, use the trade and book endpoints along with the websocket feed.
"""
type CoinbaseProductHistoricalRate {
  """
  Time is the bucket start time
  """
  time: Time

  """
  Low is the lowest price during the bucket interval
  """
  low: Float

  """
  High is the highest price during the bucket interval
  """
  high: Float

  """
  Open is the opening price (first trade) in the bucket interval
  """
  open: Float

  """
  Close is the closing price (last trade) in the bucket interval
  """
  close: Float

  """
  Volume is the volume of trading activity during the bucket interval
  """
  volume: Float
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_product_order_book.graphqls", Input: `"""
CoinbaseProductOrderBook holds bid/ask data as a list of open orders for a
product. The amount of detail shown can be customized with the level
parameter
"""
type CoinbaseProductOrderBook {
  """
  sequence represents the nth iterration of the order book update
  """
  sequence: Int

  """
  bids are the object encapsulations of the list of data returned by coinbase.
  More specifically, a bid price refer to the highest price that traders are
  willing to pay for a product
  """
  bids: [CoinbaseProductOrderBookBidAsk]

  """
  asks are the object encapsulations of the list of data returned by coinbase.
  More specifically, ab ask price refers to the lowest price that the owners of
  that product are willing to sell it for
  """
  asks: [CoinbaseProductOrderBookBidAsk]
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_product_order_book_bid_ask.graphqls", Input: `"""
CoinbaseProductOrderBookBidAsk is the object encapsulation of the a list of
values defined by the level passed to the client
"""
type CoinbaseProductOrderBookBidAsk {
  """
  price is either bid/ask price
  """
  price: Float

  """
  size is the amount of the product purchased at the bid/ask price
  """
  size: Float

  """
  numOrders orders executed at the price, specific to level 2
  """
  numOrders: Int

  """
  orderID is the uuid associated with the order, specific to level 3
  """
  orderID: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_product_trade.graphqls", Input: `"""
CoinbaseProductTrade lists the latest trades for a product
"""
type CoinbaseProductTrade {
  time: Time
  tradeID: Int
  price: Float
  size: Float

  """
  side indicates the maker order side. The maker order is the order that was
  open on the order book. buy side indicates a down-tick because the maker was a
  buy order and their order was removed. Conversely, sell side indicates an
  up-tick.
  """
  side: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_time.graphqls", Input: `"""
CoinbaseTime encapsulates the coinbase API server time
"""
type CoinbaseTime {
  iso: String

  """
  epoch represents decimal seconds since Unix Epoch
  """
  epoch: Float
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_wallet.graphqls", Input: `type CoinbaseBankCountry {
  name: String
  code: String
}

type CoinbaseSEPADepositInformation {
  iban: String
  swift: String
  bankName: String
  bankAddress: String
  bankCountry: CoinbaseBankCountry
  accountName: String
  accountAddress: String
  reference: String
}

type CoinbaseSWIFTDepositInformation {
  accountNumber: String
  bankName: String
  bankAddress: String
  bankCountry: CoinbaseBankCountry
  accountName: String
  accountAddress: String
  reference: String
}

type CoinbaseUKDepositInformation {
  sortCode: String
  accountNumber: String
  bankName: String
  accountName: String
  reference: String
}

type CoinbaseWireDepositInformation {
  accountNumber: String
  routingNumber: String
  bankName: String
  bankAddress: String
  bankCountry: CoinbaseBankCountry
  accountName: String
  accountAddress: String
  reference: String
}

type CoinbaseWallet {
  id: String
  name: String
  balance: Float
  currency: String
  type: String
  primary: Boolean
  active: Boolean
  availableOnConsumer: Boolean
  ready: Boolean
  wireDepositInformation: CoinbaseWireDepositInformation
  swiftDepositInformation: CoinbaseSWIFTDepositInformation
  sepaDepositInformation: CoinbaseSEPADepositInformation
  ukDepositInformation: CoinbaseUKDepositInformation
  destinationTagName: String
  destinationTagRegex: String
  holdBalance: Float
  holdCurrency: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbse_product_ticker.graphqls", Input: `"""
CoinbaseProductTicket encapsulates snapshot information about the last trade
(tick), best bid/ask and 24h volume.  Polling is discouraged in favor of
connecting via the websocket stream and listening for match messages
"""
type CoinbaseProductTicker {
  tradeID: Int
  price: Float
  size: Float
  bid: Float
  ask: Float
  volume: Float
  time: Time
}
`, BuiltIn: false},
	{Name: "graph/schema/scalars.graphqls", Input: `scalar EntryType
scalar OrderCancelTime
scalar OrderSide
scalar OrderStop
scalar OrderSTP
scalar OrderType
scalar TimeInForce
scalar Time
`, BuiltIn: false},
	{Name: "graph/schema/schema.graphqls", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Query {
  coinbaseAccountLedger(
    id: String!
    opts: CoinbaseAccountLedgerOptions
  ): [CoinbaseAccountLedger]

  """
  List holds of an account that belong to the same profile as the API key. Holds
  are placed on an account for any active orders or pending withdraw requests.
  As an order is filled, the hold amount is updated. If an order is canceled,
  any remaining hold is removed. For a withdraw, once it is completed, the hold
  is removed
  """
  coinbaseAccountHold(
    id: String!
    opts: CoinbaseAccountHoldOptions
  ): [CoinbaseAccountHold]

  coinbaseAccount(id: String!): CoinbaseAccount
  coinbaseAccounts(test: String): [CoinbaseAccount]

  coinbaseAccountTransfer(
    id: String!
    opts: CoinbaseAccountTransferOptions
  ): [CoinbaseAccountTransfer]

  coinbaseWallets(_filler_: String): [CoinbaseWallet]

  ####

  """
  Get a single order by order id from the profile that the API key belongs to.
  """
  clinbaseClientOrder(clientOID: String!): CoinbaseOrder

  coinbaseCurrencies(test: String): [CoinbaseCurrency]
  coinbaseCurrency(id: String!): CoinbaseCurrency

  """
  Get a single order by order id from the profile that the API key belongs to.
  """
  coinbaseOrder(id: String!): CoinbaseOrder

  coinbaseProducts(test: String): [CoinbaseProduct]

  coinbaseProduct(
    """
    id is the product of the form {baseCurrency}-{quoteCurrency}
    """
    id: String!
  ): CoinbaseProduct

  coinbaseProductDailyStats(
    """
    id is the product of the form {baseCurrency}-{quoteCurrency}
    """
    id: String!
  ): CoinbaseProductDailyStats

  coinbaseProductHistoricalRate(
    """
    id is the product of the form {baseCurrency}-{quoteCurrency}
    """
    id: String!

    """
    start time in ISO 8601
    """
    start: String!

    """
    end time in ISO 8601
    """
    end: String!

    """
    granularity must be one of the following values:

    	{60, 300, 900, 3600, 21600, 86400}

    Otherwise, your request will be rejected. These values correspond to
    timeslices representing one minute, five minutes, fifteen minutes, one hour,
    six hours, and one day, respectively.
    """
    granularity: Int!
  ): [CoinbaseProductHistoricalRate]

  coinbaseProductOrderBook(
    """
    id is the product of the form {baseCurrency}-{quoteCurrency}
    """
    id: String!
    level: String!
  ): CoinbaseProductOrderBook

  coinbaseProductTicker(
    """
    id is the product of the form {baseCurrency}-{quoteCurrency}
    """
    id: String!
  ): CoinbaseProductTicker

  coinbaseProductTrade(
    """
    id is the product of the form {baseCurrency}-{quoteCurrency}
    """
    id: String!
  ): [CoinbaseProductTrade]

  coinbaseTime(test: String): CoinbaseTime
}

type Mutation {
  """
  You can place two types of orders: limit and market. Orders can only be placed
  if your account has sufficient funds. Each profile can have a maximum of 500
  open orders on a product. Once reached, the profile will not be able to place
  any new orders until the total number of open orders is below 500. Once an
  order is placed, your account funds will be put on hold for the duration of
  the order. How much and which funds are put on hold depends on the order type
  and parameters specified. See the Holds details below.
  """
  createCoinbaseLimitOrder(input: CoinbaseOrderInput): CoinbaseOrder
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_createCoinbaseLimitOrder_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.CoinbaseOrderInput
	if tmp, ok := rawArgs["input"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
		arg0, err = ec.unmarshalOCoinbaseOrderInput2cqlmodelCoinbaseOrderInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["input"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_clinbaseClientOrder_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["clientOID"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientOID"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["clientOID"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseAccountHold_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *model.CoinbaseAccountHoldOptions
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		arg1, err = ec.unmarshalOCoinbaseAccountHoldOptions2cqlmodelCoinbaseAccountHoldOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["opts"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseAccountLedger_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *model.CoinbaseAccountLedgerOptions
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		arg1, err = ec.unmarshalOCoinbaseAccountLedgerOptions2cqlmodelCoinbaseAccountLedgerOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["opts"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseAccountTransfer_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *model.CoinbaseAccountTransferOptions
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		arg1, err = ec.unmarshalOCoinbaseAccountTransferOptions2cqlmodelCoinbaseAccountTransferOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["opts"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseAccount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseAccounts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["test"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("test"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["test"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseCurrencies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["test"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("test"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["test"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseCurrency_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseOrder_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseProductDailyStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseProductHistoricalRate_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["start"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("start"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["start"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["end"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("end"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["end"] = arg2
	var arg3 int
	if tmp, ok := rawArgs["granularity"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("granularity"))
		arg3, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["granularity"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseProductOrderBook_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["level"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["level"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseProductTicker_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseProductTrade_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseProduct_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseProducts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["test"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("test"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["test"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseTime_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["test"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("test"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["test"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseWallets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["_filler_"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("_filler_"))
		arg0, err = ec.unmarshalOString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["_filler_"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _CoinbaseAccount_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccount_currency(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccount_balance(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccount_available(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Available, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccount_hold(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccount_profileID(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProfileID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccount_tradingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TradingEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountHold_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountHold) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountHold",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountHold_accountID(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountHold) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountHold",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountHold_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountHold) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountHold",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountHold_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountHold) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountHold",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountHold_amount(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountHold) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountHold",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountHold_type(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountHold) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountHold",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountHold_ref(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountHold) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountHold",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedger_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedger_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedger_amount(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedger_balance(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedger_type(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(scalar.EntryType)
	fc.Result = res
	return ec.marshalOEntryType2cqlscalarEntryType(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedger_details(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CoinbaseAccountLedgerDetails)
	fc.Result = res
	return ec.marshalOCoinbaseAccountLedgerDetails2cqlmodelCoinbaseAccountLedgerDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedgerDetails_orderID(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedgerDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedgerDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedgerDetails_tradeID(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedgerDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedgerDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TradeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedgerDetails_productID(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedgerDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedgerDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProductID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_type(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_completedAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_canceledAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanceledAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_amount(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_userNonce(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserNonce, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_details(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CoinbaseAccountTransferDetails)
	fc.Result = res
	return ec.marshalOCoinbaseAccountTransferDetails2cqlmodelCoinbaseAccountTransferDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransferDetails_coinbaseAccountID(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransferDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransferDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinbaseAccountID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransferDetails_coinbaseTransactionID(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransferDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransferDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinbaseTransactionID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransferDetails_coinbasePaymentMethodID(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransferDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransferDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinbasePaymentMethodID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseBankCountry_name(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseBankCountry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseBankCountry",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseBankCountry_code(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseBankCountry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseBankCountry",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_name(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_minSize(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_status(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_message(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_maxPrecision(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxPrecision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_convertibleTo(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConvertibleTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_details(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CoinbaseCurrencyDetails)
	fc.Result = res
	return ec.marshalOCoinbaseCurrencyDetails2cqlmodelCoinbaseCurrencyDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_displayName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_processingTimeSeconds(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessingTimeSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_minWithdrawalAmount(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinWithdrawalAmount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_maxWithdrawalAmount(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxWithdrawalAmount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_type(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_symbol(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Symbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_networkConfirmations(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NetworkConfirmations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_sortOrder(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SortOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_cryptoAddressLink(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CryptoAddressLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_cryptoTransactionLink(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CryptoTransactionLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_pushPaymentMethods(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PushPaymentMethods, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_groupTypes(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_price(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_size(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_productID(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProductID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_side(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Side, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(scalar.OrderSide)
	fc.Result = res
	return ec.marshalOOrderSide2cqlscalarOrderSide(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_stp(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.STP, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(scalar.OrderSTP)
	fc.Result = res
	return ec.marshalOOrderSTP2cqlscalarOrderSTP(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_type(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(scalar.OrderType)
	fc.Result = res
	return ec.marshalOOrderType2cqlscalarOrderType(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_timeInForce(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeInForce, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(scalar.TimeInForce)
	fc.Result = res
	return ec.marshalOTimeInForce2cqlscalarTimeInForce(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_postOnly(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostOnly, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_fillFees(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FillFees, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_filledSize(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilledSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_executedValue(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutedValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_status(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_settled(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Settled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_funds(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Funds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseOrder_specifiedFunds(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseOrder) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseOrder",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedFunds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_displayName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_baseCurrency(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseCurrency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_quoteCurrency(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuoteCurrency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_baseIncrement(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseIncrement, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_quoteIncrement(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QuoteIncrement, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_baseMinSize(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseMinSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_baseMaxSize(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseMaxSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_minMarketFunds(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinMarketFunds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_maxMarketFunds(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxMarketFunds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_status(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_statusMessage(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StatusMessage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_cancelOnly(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CancelOnly, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_limitOnly(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LimitOnly, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_postOnly(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PostOnly, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_tradingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TradingDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProduct_fxStablecoin(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProduct) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProduct",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FXStablecoin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductDailyStats_open(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductDailyStats) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductDailyStats",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Open, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductDailyStats_high(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductDailyStats) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductDailyStats",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.High, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductDailyStats_low(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductDailyStats) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductDailyStats",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Low, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductDailyStats_volume(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductDailyStats) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductDailyStats",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Volume, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductDailyStats_last(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductDailyStats) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductDailyStats",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Last, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductDailyStats_volume30Day(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductDailyStats) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductDailyStats",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Volume30Day, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductHistoricalRate_time(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductHistoricalRate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductHistoricalRate",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductHistoricalRate_low(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductHistoricalRate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductHistoricalRate",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Low, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductHistoricalRate_high(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductHistoricalRate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductHistoricalRate",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.High, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductHistoricalRate_open(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductHistoricalRate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductHistoricalRate",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Open, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductHistoricalRate_close(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductHistoricalRate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductHistoricalRate",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Close, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductHistoricalRate_volume(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductHistoricalRate) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductHistoricalRate",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Volume, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductOrderBook_sequence(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductOrderBook) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductOrderBook",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sequence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductOrderBook_bids(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductOrderBook) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductOrderBook",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CoinbaseProductOrderBook().Bids(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseProductOrderBookBidAsk)
	fc.Result = res
	return ec.marshalOCoinbaseProductOrderBookBidAsk2cqlmodelCoinbaseProductOrderBookBidAsk(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductOrderBook_asks(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductOrderBook) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductOrderBook",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.CoinbaseProductOrderBook().Asks(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseProductOrderBookBidAsk)
	fc.Result = res
	return ec.marshalOCoinbaseProductOrderBookBidAsk2cqlmodelCoinbaseProductOrderBookBidAsk(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductOrderBookBidAsk_price(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductOrderBookBidAsk) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductOrderBookBidAsk",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductOrderBookBidAsk_size(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductOrderBookBidAsk) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductOrderBookBidAsk",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductOrderBookBidAsk_numOrders(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductOrderBookBidAsk) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductOrderBookBidAsk",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumOrders, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductOrderBookBidAsk_orderID(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductOrderBookBidAsk) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductOrderBookBidAsk",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductTicker_tradeID(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductTicker) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductTicker",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TradeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductTicker_price(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductTicker) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductTicker",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductTicker_size(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductTicker) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductTicker",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductTicker_bid(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductTicker) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductTicker",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Bid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductTicker_ask(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductTicker) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductTicker",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ask, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductTicker_volume(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductTicker) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductTicker",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Volume, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductTicker_time(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductTicker) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductTicker",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductTrade_time(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductTrade) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductTrade",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductTrade_tradeID(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductTrade) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductTrade",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TradeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductTrade_price(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductTrade) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductTrade",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Price, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductTrade_size(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductTrade) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductTrade",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseProductTrade_side(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseProductTrade) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseProductTrade",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Side, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSEPADepositInformation_iban(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSEPADepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSEPADepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IBAN, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSEPADepositInformation_swift(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSEPADepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSEPADepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SWIFT, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSEPADepositInformation_bankName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSEPADepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSEPADepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSEPADepositInformation_bankAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSEPADepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSEPADepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSEPADepositInformation_bankCountry(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSEPADepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSEPADepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankCountry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CoinbaseBankCountry)
	fc.Result = res
	return ec.marshalOCoinbaseBankCountry2cqlmodelCoinbaseBankCountry(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSEPADepositInformation_accountName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSEPADepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSEPADepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSEPADepositInformation_accountAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSEPADepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSEPADepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSEPADepositInformation_reference(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSEPADepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSEPADepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reference, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSWIFTDepositInformation_accountNumber(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSWIFTDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSWIFTDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSWIFTDepositInformation_bankName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSWIFTDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSWIFTDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSWIFTDepositInformation_bankAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSWIFTDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSWIFTDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSWIFTDepositInformation_bankCountry(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSWIFTDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSWIFTDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankCountry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CoinbaseBankCountry)
	fc.Result = res
	return ec.marshalOCoinbaseBankCountry2cqlmodelCoinbaseBankCountry(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSWIFTDepositInformation_accountName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSWIFTDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSWIFTDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSWIFTDepositInformation_accountAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSWIFTDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSWIFTDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSWIFTDepositInformation_reference(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSWIFTDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSWIFTDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reference, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseTime_iso(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseTime) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseTime",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ISO, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseTime_epoch(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseTime) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseTime",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Epoch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseUKDepositInformation_sortCode(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseUKDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseUKDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SortCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseUKDepositInformation_accountNumber(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseUKDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseUKDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseUKDepositInformation_bankName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseUKDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseUKDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseUKDepositInformation_accountName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseUKDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseUKDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseUKDepositInformation_reference(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseUKDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseUKDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reference, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_name(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_balance(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_currency(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_type(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_primary(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Primary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_active(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_availableOnConsumer(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailableOnConsumer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_ready(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ready, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_wireDepositInformation(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WireDepositInformation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CoinbaseWireDepositInformation)
	fc.Result = res
	return ec.marshalOCoinbaseWireDepositInformation2cqlmodelCoinbaseWireDepositInformation(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_swiftDepositInformation(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SWIFTDepositInformation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CoinbaseSWIFTDepositInformation)
	fc.Result = res
	return ec.marshalOCoinbaseSWIFTDepositInformation2cqlmodelCoinbaseSWIFTDepositInformation(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_sepaDepositInformation(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SEPADepositInformation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CoinbaseSEPADepositInformation)
	fc.Result = res
	return ec.marshalOCoinbaseSEPADepositInformation2cqlmodelCoinbaseSEPADepositInformation(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_ukDepositInformation(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UKDepositInformation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CoinbaseUKDepositInformation)
	fc.Result = res
	return ec.marshalOCoinbaseUKDepositInformation2cqlmodelCoinbaseUKDepositInformation(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_destinationTagName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DestinationTagName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_destinationTagRegex(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DestinationTagRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_holdBalance(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoldBalance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_holdCurrency(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoldCurrency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_accountNumber(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_routingNumber(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoutingNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_bankName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_bankAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_bankCountry(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankCountry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.CoinbaseBankCountry)
	fc.Result = res
	return ec.marshalOCoinbaseBankCountry2cqlmodelCoinbaseBankCountry(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_accountName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_accountAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_reference(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reference, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_createCoinbaseLimitOrder(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_createCoinbaseLimitOrder_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateCoinbaseLimitOrder(rctx, args["input"].(*model.CoinbaseOrderInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseOrder)
	fc.Result = res
	return ec.marshalOCoinbaseOrder2cqlmodelCoinbaseOrder(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseAccountLedger(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseAccountLedger_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseAccountLedger(rctx, args["id"].(string), args["opts"].(*model.CoinbaseAccountLedgerOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseAccountLedger)
	fc.Result = res
	return ec.marshalOCoinbaseAccountLedger2cqlmodelCoinbaseAccountLedger(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseAccountHold(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseAccountHold_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseAccountHold(rctx, args["id"].(string), args["opts"].(*model.CoinbaseAccountHoldOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseAccountHold)
	fc.Result = res
	return ec.marshalOCoinbaseAccountHold2cqlmodelCoinbaseAccountHold(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseAccount_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseAccount(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseAccount)
	fc.Result = res
	return ec.marshalOCoinbaseAccount2cqlmodelCoinbaseAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseAccounts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseAccounts_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseAccounts(rctx, args["test"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseAccount)
	fc.Result = res
	return ec.marshalOCoinbaseAccount2cqlmodelCoinbaseAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseAccountTransfer(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseAccountTransfer_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseAccountTransfer(rctx, args["id"].(string), args["opts"].(*model.CoinbaseAccountTransferOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseAccountTransfer)
	fc.Result = res
	return ec.marshalOCoinbaseAccountTransfer2cqlmodelCoinbaseAccountTransfer(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseWallets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseWallets_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseWallets(rctx, args["_filler_"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseWallet)
	fc.Result = res
	return ec.marshalOCoinbaseWallet2cqlmodelCoinbaseWallet(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_clinbaseClientOrder(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_clinbaseClientOrder_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClinbaseClientOrder(rctx, args["clientOID"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseOrder)
	fc.Result = res
	return ec.marshalOCoinbaseOrder2cqlmodelCoinbaseOrder(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseCurrencies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseCurrencies_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseCurrencies(rctx, args["test"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseCurrency)
	fc.Result = res
	return ec.marshalOCoinbaseCurrency2cqlmodelCoinbaseCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseCurrency(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseCurrency_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseCurrency(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseCurrency)
	fc.Result = res
	return ec.marshalOCoinbaseCurrency2cqlmodelCoinbaseCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseOrder(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseOrder_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseOrder(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseOrder)
	fc.Result = res
	return ec.marshalOCoinbaseOrder2cqlmodelCoinbaseOrder(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseProducts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseProducts_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseProducts(rctx, args["test"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseProduct)
	fc.Result = res
	return ec.marshalOCoinbaseProduct2cqlmodelCoinbaseProduct(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseProduct(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseProduct_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseProduct(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseProduct)
	fc.Result = res
	return ec.marshalOCoinbaseProduct2cqlmodelCoinbaseProduct(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseProductDailyStats(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseProductDailyStats_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseProductDailyStats(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseProductDailyStats)
	fc.Result = res
	return ec.marshalOCoinbaseProductDailyStats2cqlmodelCoinbaseProductDailyStats(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseProductHistoricalRate(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseProductHistoricalRate_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseProductHistoricalRate(rctx, args["id"].(string), args["start"].(string), args["end"].(string), args["granularity"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseProductHistoricalRate)
	fc.Result = res
	return ec.marshalOCoinbaseProductHistoricalRate2cqlmodelCoinbaseProductHistoricalRate(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseProductOrderBook(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseProductOrderBook_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseProductOrderBook(rctx, args["id"].(string), args["level"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseProductOrderBook)
	fc.Result = res
	return ec.marshalOCoinbaseProductOrderBook2cqlmodelCoinbaseProductOrderBook(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseProductTicker(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseProductTicker_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseProductTicker(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseProductTicker)
	fc.Result = res
	return ec.marshalOCoinbaseProductTicker2cqlmodelCoinbaseProductTicker(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseProductTrade(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseProductTrade_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseProductTrade(rctx, args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseProductTrade)
	fc.Result = res
	return ec.marshalOCoinbaseProductTrade2cqlmodelCoinbaseProductTrade(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseTime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseTime_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseTime(rctx, args["test"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseTime)
	fc.Result = res
	return ec.marshalOCoinbaseTime2cqlmodelCoinbaseTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCoinbaseAccountHoldOptions(ctx context.Context, obj interface{}) (model.CoinbaseAccountHoldOptions, error) {
	var it model.CoinbaseAccountHoldOptions
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			it.Before, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			it.After, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			it.Limit, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCoinbaseAccountLedgerOptions(ctx context.Context, obj interface{}) (model.CoinbaseAccountLedgerOptions, error) {
	var it model.CoinbaseAccountLedgerOptions
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			it.Before, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			it.After, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			it.StartDate, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
			it.EndDate, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			it.Limit, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "profileID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("profileID"))
			it.ProfileID, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCoinbaseAccountTransferOptions(ctx context.Context, obj interface{}) (model.CoinbaseAccountTransferOptions, error) {
	var it model.CoinbaseAccountTransferOptions
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			it.Before, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			it.After, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			it.Limit, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCoinbaseOrderInput(ctx context.Context, obj interface{}) (model.CoinbaseOrderInput, error) {
	var it model.CoinbaseOrderInput
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "side":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("side"))
			it.Side, err = ec.unmarshalNOrderSide2cqlscalarOrderSide(ctx, v)
			if err != nil {
				return it, err
			}
		case "productID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("productID"))
			it.ProductID, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "clientOID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientOID"))
			it.ClientOid, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "stp":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stp"))
			it.Stp, err = ec.unmarshalOOrderSTP2cqlscalarOrderSTP(ctx, v)
			if err != nil {
				return it, err
			}
		case "stop":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stop"))
			it.Stop, err = ec.unmarshalOOrderStop2cqlscalarOrderSide(ctx, v)
			if err != nil {
				return it, err
			}
		case "stopPrice":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stopPrice"))
			it.StopPrice, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "price":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("price"))
			it.Price, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "size":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			it.Size, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "timeInForce":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeInForce"))
			it.TimeInForce, err = ec.unmarshalOTimeInForce2cqlscalarTimeInForce(ctx, v)
			if err != nil {
				return it, err
			}
		case "cancelAfter":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cancelAfter"))
			it.CancelAfter, err = ec.unmarshalOOrderCancelTime2cqlscalarOrderCancelTime(ctx, v)
			if err != nil {
				return it, err
			}
		case "postOnly":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("postOnly"))
			it.PostOnly, err = ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCoinbaseOrderQueryParameters(ctx context.Context, obj interface{}) (model.CoinbaseOrderQueryParameters, error) {
	var it model.CoinbaseOrderQueryParameters
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "statuses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			it.Statuses, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "products":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("products"))
			it.Products, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "startDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			it.StartDate, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
			it.EndDate, err = ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			it.Before, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			it.After, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			it.Limit, err = ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var coinbaseAccountImplementors = []string{"CoinbaseAccount"}

func (ec *executionContext) _CoinbaseAccount(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseAccount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseAccountImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseAccount")
		case "id":
			out.Values[i] = ec._CoinbaseAccount_id(ctx, field, obj)
		case "currency":
			out.Values[i] = ec._CoinbaseAccount_currency(ctx, field, obj)
		case "balance":
			out.Values[i] = ec._CoinbaseAccount_balance(ctx, field, obj)
		case "available":
			out.Values[i] = ec._CoinbaseAccount_available(ctx, field, obj)
		case "hold":
			out.Values[i] = ec._CoinbaseAccount_hold(ctx, field, obj)
		case "profileID":
			out.Values[i] = ec._CoinbaseAccount_profileID(ctx, field, obj)
		case "tradingEnabled":
			out.Values[i] = ec._CoinbaseAccount_tradingEnabled(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseAccountHoldImplementors = []string{"CoinbaseAccountHold"}

func (ec *executionContext) _CoinbaseAccountHold(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseAccountHold) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseAccountHoldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseAccountHold")
		case "id":
			out.Values[i] = ec._CoinbaseAccountHold_id(ctx, field, obj)
		case "accountID":
			out.Values[i] = ec._CoinbaseAccountHold_accountID(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._CoinbaseAccountHold_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._CoinbaseAccountHold_updatedAt(ctx, field, obj)
		case "amount":
			out.Values[i] = ec._CoinbaseAccountHold_amount(ctx, field, obj)
		case "type":
			out.Values[i] = ec._CoinbaseAccountHold_type(ctx, field, obj)
		case "ref":
			out.Values[i] = ec._CoinbaseAccountHold_ref(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseAccountLedgerImplementors = []string{"CoinbaseAccountLedger"}

func (ec *executionContext) _CoinbaseAccountLedger(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseAccountLedger) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseAccountLedgerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseAccountLedger")
		case "id":
			out.Values[i] = ec._CoinbaseAccountLedger_id(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._CoinbaseAccountLedger_createdAt(ctx, field, obj)
		case "amount":
			out.Values[i] = ec._CoinbaseAccountLedger_amount(ctx, field, obj)
		case "balance":
			out.Values[i] = ec._CoinbaseAccountLedger_balance(ctx, field, obj)
		case "type":
			out.Values[i] = ec._CoinbaseAccountLedger_type(ctx, field, obj)
		case "details":
			out.Values[i] = ec._CoinbaseAccountLedger_details(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseAccountLedgerDetailsImplementors = []string{"CoinbaseAccountLedgerDetails"}

func (ec *executionContext) _CoinbaseAccountLedgerDetails(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseAccountLedgerDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseAccountLedgerDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseAccountLedgerDetails")
		case "orderID":
			out.Values[i] = ec._CoinbaseAccountLedgerDetails_orderID(ctx, field, obj)
		case "tradeID":
			out.Values[i] = ec._CoinbaseAccountLedgerDetails_tradeID(ctx, field, obj)
		case "productID":
			out.Values[i] = ec._CoinbaseAccountLedgerDetails_productID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseAccountTransferImplementors = []string{"CoinbaseAccountTransfer"}

func (ec *executionContext) _CoinbaseAccountTransfer(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseAccountTransfer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseAccountTransferImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseAccountTransfer")
		case "id":
			out.Values[i] = ec._CoinbaseAccountTransfer_id(ctx, field, obj)
		case "type":
			out.Values[i] = ec._CoinbaseAccountTransfer_type(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._CoinbaseAccountTransfer_createdAt(ctx, field, obj)
		case "completedAt":
			out.Values[i] = ec._CoinbaseAccountTransfer_completedAt(ctx, field, obj)
		case "canceledAt":
			out.Values[i] = ec._CoinbaseAccountTransfer_canceledAt(ctx, field, obj)
		case "processedAt":
			out.Values[i] = ec._CoinbaseAccountTransfer_processedAt(ctx, field, obj)
		case "amount":
			out.Values[i] = ec._CoinbaseAccountTransfer_amount(ctx, field, obj)
		case "userNonce":
			out.Values[i] = ec._CoinbaseAccountTransfer_userNonce(ctx, field, obj)
		case "details":
			out.Values[i] = ec._CoinbaseAccountTransfer_details(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseAccountTransferDetailsImplementors = []string{"CoinbaseAccountTransferDetails"}

func (ec *executionContext) _CoinbaseAccountTransferDetails(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseAccountTransferDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseAccountTransferDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseAccountTransferDetails")
		case "coinbaseAccountID":
			out.Values[i] = ec._CoinbaseAccountTransferDetails_coinbaseAccountID(ctx, field, obj)
		case "coinbaseTransactionID":
			out.Values[i] = ec._CoinbaseAccountTransferDetails_coinbaseTransactionID(ctx, field, obj)
		case "coinbasePaymentMethodID":
			out.Values[i] = ec._CoinbaseAccountTransferDetails_coinbasePaymentMethodID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseBankCountryImplementors = []string{"CoinbaseBankCountry"}

func (ec *executionContext) _CoinbaseBankCountry(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseBankCountry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseBankCountryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseBankCountry")
		case "name":
			out.Values[i] = ec._CoinbaseBankCountry_name(ctx, field, obj)
		case "code":
			out.Values[i] = ec._CoinbaseBankCountry_code(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseCurrencyImplementors = []string{"CoinbaseCurrency"}

func (ec *executionContext) _CoinbaseCurrency(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseCurrency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseCurrencyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseCurrency")
		case "id":
			out.Values[i] = ec._CoinbaseCurrency_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec._CoinbaseCurrency_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "minSize":
			out.Values[i] = ec._CoinbaseCurrency_minSize(ctx, field, obj)
		case "status":
			out.Values[i] = ec._CoinbaseCurrency_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._CoinbaseCurrency_message(ctx, field, obj)
		case "maxPrecision":
			out.Values[i] = ec._CoinbaseCurrency_maxPrecision(ctx, field, obj)
		case "convertibleTo":
			out.Values[i] = ec._CoinbaseCurrency_convertibleTo(ctx, field, obj)
		case "details":
			out.Values[i] = ec._CoinbaseCurrency_details(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._CoinbaseCurrency_displayName(ctx, field, obj)
		case "processingTimeSeconds":
			out.Values[i] = ec._CoinbaseCurrency_processingTimeSeconds(ctx, field, obj)
		case "minWithdrawalAmount":
			out.Values[i] = ec._CoinbaseCurrency_minWithdrawalAmount(ctx, field, obj)
		case "maxWithdrawalAmount":
			out.Values[i] = ec._CoinbaseCurrency_maxWithdrawalAmount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseCurrencyDetailsImplementors = []string{"CoinbaseCurrencyDetails"}

func (ec *executionContext) _CoinbaseCurrencyDetails(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseCurrencyDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseCurrencyDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseCurrencyDetails")
		case "type":
			out.Values[i] = ec._CoinbaseCurrencyDetails_type(ctx, field, obj)
		case "symbol":
			out.Values[i] = ec._CoinbaseCurrencyDetails_symbol(ctx, field, obj)
		case "networkConfirmations":
			out.Values[i] = ec._CoinbaseCurrencyDetails_networkConfirmations(ctx, field, obj)
		case "sortOrder":
			out.Values[i] = ec._CoinbaseCurrencyDetails_sortOrder(ctx, field, obj)
		case "cryptoAddressLink":
			out.Values[i] = ec._CoinbaseCurrencyDetails_cryptoAddressLink(ctx, field, obj)
		case "cryptoTransactionLink":
			out.Values[i] = ec._CoinbaseCurrencyDetails_cryptoTransactionLink(ctx, field, obj)
		case "pushPaymentMethods":
			out.Values[i] = ec._CoinbaseCurrencyDetails_pushPaymentMethods(ctx, field, obj)
		case "groupTypes":
			out.Values[i] = ec._CoinbaseCurrencyDetails_groupTypes(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseOrderImplementors = []string{"CoinbaseOrder"}

func (ec *executionContext) _CoinbaseOrder(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseOrder) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseOrderImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseOrder")
		case "id":
			out.Values[i] = ec._CoinbaseOrder_id(ctx, field, obj)
		case "price":
			out.Values[i] = ec._CoinbaseOrder_price(ctx, field, obj)
		case "size":
			out.Values[i] = ec._CoinbaseOrder_size(ctx, field, obj)
		case "productID":
			out.Values[i] = ec._CoinbaseOrder_productID(ctx, field, obj)
		case "side":
			out.Values[i] = ec._CoinbaseOrder_side(ctx, field, obj)
		case "stp":
			out.Values[i] = ec._CoinbaseOrder_stp(ctx, field, obj)
		case "type":
			out.Values[i] = ec._CoinbaseOrder_type(ctx, field, obj)
		case "timeInForce":
			out.Values[i] = ec._CoinbaseOrder_timeInForce(ctx, field, obj)
		case "postOnly":
			out.Values[i] = ec._CoinbaseOrder_postOnly(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._CoinbaseOrder_createdAt(ctx, field, obj)
		case "fillFees":
			out.Values[i] = ec._CoinbaseOrder_fillFees(ctx, field, obj)
		case "filledSize":
			out.Values[i] = ec._CoinbaseOrder_filledSize(ctx, field, obj)
		case "executedValue":
			out.Values[i] = ec._CoinbaseOrder_executedValue(ctx, field, obj)
		case "status":
			out.Values[i] = ec._CoinbaseOrder_status(ctx, field, obj)
		case "settled":
			out.Values[i] = ec._CoinbaseOrder_settled(ctx, field, obj)
		case "funds":
			out.Values[i] = ec._CoinbaseOrder_funds(ctx, field, obj)
		case "specifiedFunds":
			out.Values[i] = ec._CoinbaseOrder_specifiedFunds(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseProductImplementors = []string{"CoinbaseProduct"}

func (ec *executionContext) _CoinbaseProduct(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseProduct) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseProductImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseProduct")
		case "id":
			out.Values[i] = ec._CoinbaseProduct_id(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._CoinbaseProduct_displayName(ctx, field, obj)
		case "baseCurrency":
			out.Values[i] = ec._CoinbaseProduct_baseCurrency(ctx, field, obj)
		case "quoteCurrency":
			out.Values[i] = ec._CoinbaseProduct_quoteCurrency(ctx, field, obj)
		case "baseIncrement":
			out.Values[i] = ec._CoinbaseProduct_baseIncrement(ctx, field, obj)
		case "quoteIncrement":
			out.Values[i] = ec._CoinbaseProduct_quoteIncrement(ctx, field, obj)
		case "baseMinSize":
			out.Values[i] = ec._CoinbaseProduct_baseMinSize(ctx, field, obj)
		case "baseMaxSize":
			out.Values[i] = ec._CoinbaseProduct_baseMaxSize(ctx, field, obj)
		case "minMarketFunds":
			out.Values[i] = ec._CoinbaseProduct_minMarketFunds(ctx, field, obj)
		case "maxMarketFunds":
			out.Values[i] = ec._CoinbaseProduct_maxMarketFunds(ctx, field, obj)
		case "status":
			out.Values[i] = ec._CoinbaseProduct_status(ctx, field, obj)
		case "statusMessage":
			out.Values[i] = ec._CoinbaseProduct_statusMessage(ctx, field, obj)
		case "cancelOnly":
			out.Values[i] = ec._CoinbaseProduct_cancelOnly(ctx, field, obj)
		case "limitOnly":
			out.Values[i] = ec._CoinbaseProduct_limitOnly(ctx, field, obj)
		case "postOnly":
			out.Values[i] = ec._CoinbaseProduct_postOnly(ctx, field, obj)
		case "tradingDisabled":
			out.Values[i] = ec._CoinbaseProduct_tradingDisabled(ctx, field, obj)
		case "fxStablecoin":
			out.Values[i] = ec._CoinbaseProduct_fxStablecoin(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseProductDailyStatsImplementors = []string{"CoinbaseProductDailyStats"}

func (ec *executionContext) _CoinbaseProductDailyStats(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseProductDailyStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseProductDailyStatsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseProductDailyStats")
		case "open":
			out.Values[i] = ec._CoinbaseProductDailyStats_open(ctx, field, obj)
		case "high":
			out.Values[i] = ec._CoinbaseProductDailyStats_high(ctx, field, obj)
		case "low":
			out.Values[i] = ec._CoinbaseProductDailyStats_low(ctx, field, obj)
		case "volume":
			out.Values[i] = ec._CoinbaseProductDailyStats_volume(ctx, field, obj)
		case "last":
			out.Values[i] = ec._CoinbaseProductDailyStats_last(ctx, field, obj)
		case "volume30Day":
			out.Values[i] = ec._CoinbaseProductDailyStats_volume30Day(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseProductHistoricalRateImplementors = []string{"CoinbaseProductHistoricalRate"}

func (ec *executionContext) _CoinbaseProductHistoricalRate(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseProductHistoricalRate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseProductHistoricalRateImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseProductHistoricalRate")
		case "time":
			out.Values[i] = ec._CoinbaseProductHistoricalRate_time(ctx, field, obj)
		case "low":
			out.Values[i] = ec._CoinbaseProductHistoricalRate_low(ctx, field, obj)
		case "high":
			out.Values[i] = ec._CoinbaseProductHistoricalRate_high(ctx, field, obj)
		case "open":
			out.Values[i] = ec._CoinbaseProductHistoricalRate_open(ctx, field, obj)
		case "close":
			out.Values[i] = ec._CoinbaseProductHistoricalRate_close(ctx, field, obj)
		case "volume":
			out.Values[i] = ec._CoinbaseProductHistoricalRate_volume(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseProductOrderBookImplementors = []string{"CoinbaseProductOrderBook"}

func (ec *executionContext) _CoinbaseProductOrderBook(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseProductOrderBook) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseProductOrderBookImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseProductOrderBook")
		case "sequence":
			out.Values[i] = ec._CoinbaseProductOrderBook_sequence(ctx, field, obj)
		case "bids":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CoinbaseProductOrderBook_bids(ctx, field, obj)
				return res
			})
		case "asks":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._CoinbaseProductOrderBook_asks(ctx, field, obj)
				return res
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseProductOrderBookBidAskImplementors = []string{"CoinbaseProductOrderBookBidAsk"}

func (ec *executionContext) _CoinbaseProductOrderBookBidAsk(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseProductOrderBookBidAsk) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseProductOrderBookBidAskImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseProductOrderBookBidAsk")
		case "price":
			out.Values[i] = ec._CoinbaseProductOrderBookBidAsk_price(ctx, field, obj)
		case "size":
			out.Values[i] = ec._CoinbaseProductOrderBookBidAsk_size(ctx, field, obj)
		case "numOrders":
			out.Values[i] = ec._CoinbaseProductOrderBookBidAsk_numOrders(ctx, field, obj)
		case "orderID":
			out.Values[i] = ec._CoinbaseProductOrderBookBidAsk_orderID(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseProductTickerImplementors = []string{"CoinbaseProductTicker"}

func (ec *executionContext) _CoinbaseProductTicker(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseProductTicker) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseProductTickerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseProductTicker")
		case "tradeID":
			out.Values[i] = ec._CoinbaseProductTicker_tradeID(ctx, field, obj)
		case "price":
			out.Values[i] = ec._CoinbaseProductTicker_price(ctx, field, obj)
		case "size":
			out.Values[i] = ec._CoinbaseProductTicker_size(ctx, field, obj)
		case "bid":
			out.Values[i] = ec._CoinbaseProductTicker_bid(ctx, field, obj)
		case "ask":
			out.Values[i] = ec._CoinbaseProductTicker_ask(ctx, field, obj)
		case "volume":
			out.Values[i] = ec._CoinbaseProductTicker_volume(ctx, field, obj)
		case "time":
			out.Values[i] = ec._CoinbaseProductTicker_time(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseProductTradeImplementors = []string{"CoinbaseProductTrade"}

func (ec *executionContext) _CoinbaseProductTrade(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseProductTrade) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseProductTradeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseProductTrade")
		case "time":
			out.Values[i] = ec._CoinbaseProductTrade_time(ctx, field, obj)
		case "tradeID":
			out.Values[i] = ec._CoinbaseProductTrade_tradeID(ctx, field, obj)
		case "price":
			out.Values[i] = ec._CoinbaseProductTrade_price(ctx, field, obj)
		case "size":
			out.Values[i] = ec._CoinbaseProductTrade_size(ctx, field, obj)
		case "side":
			out.Values[i] = ec._CoinbaseProductTrade_side(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseSEPADepositInformationImplementors = []string{"CoinbaseSEPADepositInformation"}

func (ec *executionContext) _CoinbaseSEPADepositInformation(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseSEPADepositInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseSEPADepositInformationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseSEPADepositInformation")
		case "iban":
			out.Values[i] = ec._CoinbaseSEPADepositInformation_iban(ctx, field, obj)
		case "swift":
			out.Values[i] = ec._CoinbaseSEPADepositInformation_swift(ctx, field, obj)
		case "bankName":
			out.Values[i] = ec._CoinbaseSEPADepositInformation_bankName(ctx, field, obj)
		case "bankAddress":
			out.Values[i] = ec._CoinbaseSEPADepositInformation_bankAddress(ctx, field, obj)
		case "bankCountry":
			out.Values[i] = ec._CoinbaseSEPADepositInformation_bankCountry(ctx, field, obj)
		case "accountName":
			out.Values[i] = ec._CoinbaseSEPADepositInformation_accountName(ctx, field, obj)
		case "accountAddress":
			out.Values[i] = ec._CoinbaseSEPADepositInformation_accountAddress(ctx, field, obj)
		case "reference":
			out.Values[i] = ec._CoinbaseSEPADepositInformation_reference(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseSWIFTDepositInformationImplementors = []string{"CoinbaseSWIFTDepositInformation"}

func (ec *executionContext) _CoinbaseSWIFTDepositInformation(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseSWIFTDepositInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseSWIFTDepositInformationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseSWIFTDepositInformation")
		case "accountNumber":
			out.Values[i] = ec._CoinbaseSWIFTDepositInformation_accountNumber(ctx, field, obj)
		case "bankName":
			out.Values[i] = ec._CoinbaseSWIFTDepositInformation_bankName(ctx, field, obj)
		case "bankAddress":
			out.Values[i] = ec._CoinbaseSWIFTDepositInformation_bankAddress(ctx, field, obj)
		case "bankCountry":
			out.Values[i] = ec._CoinbaseSWIFTDepositInformation_bankCountry(ctx, field, obj)
		case "accountName":
			out.Values[i] = ec._CoinbaseSWIFTDepositInformation_accountName(ctx, field, obj)
		case "accountAddress":
			out.Values[i] = ec._CoinbaseSWIFTDepositInformation_accountAddress(ctx, field, obj)
		case "reference":
			out.Values[i] = ec._CoinbaseSWIFTDepositInformation_reference(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseTimeImplementors = []string{"CoinbaseTime"}

func (ec *executionContext) _CoinbaseTime(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseTime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseTimeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseTime")
		case "iso":
			out.Values[i] = ec._CoinbaseTime_iso(ctx, field, obj)
		case "epoch":
			out.Values[i] = ec._CoinbaseTime_epoch(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseUKDepositInformationImplementors = []string{"CoinbaseUKDepositInformation"}

func (ec *executionContext) _CoinbaseUKDepositInformation(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseUKDepositInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseUKDepositInformationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseUKDepositInformation")
		case "sortCode":
			out.Values[i] = ec._CoinbaseUKDepositInformation_sortCode(ctx, field, obj)
		case "accountNumber":
			out.Values[i] = ec._CoinbaseUKDepositInformation_accountNumber(ctx, field, obj)
		case "bankName":
			out.Values[i] = ec._CoinbaseUKDepositInformation_bankName(ctx, field, obj)
		case "accountName":
			out.Values[i] = ec._CoinbaseUKDepositInformation_accountName(ctx, field, obj)
		case "reference":
			out.Values[i] = ec._CoinbaseUKDepositInformation_reference(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseWalletImplementors = []string{"CoinbaseWallet"}

func (ec *executionContext) _CoinbaseWallet(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseWallet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseWalletImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseWallet")
		case "id":
			out.Values[i] = ec._CoinbaseWallet_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._CoinbaseWallet_name(ctx, field, obj)
		case "balance":
			out.Values[i] = ec._CoinbaseWallet_balance(ctx, field, obj)
		case "currency":
			out.Values[i] = ec._CoinbaseWallet_currency(ctx, field, obj)
		case "type":
			out.Values[i] = ec._CoinbaseWallet_type(ctx, field, obj)
		case "primary":
			out.Values[i] = ec._CoinbaseWallet_primary(ctx, field, obj)
		case "active":
			out.Values[i] = ec._CoinbaseWallet_active(ctx, field, obj)
		case "availableOnConsumer":
			out.Values[i] = ec._CoinbaseWallet_availableOnConsumer(ctx, field, obj)
		case "ready":
			out.Values[i] = ec._CoinbaseWallet_ready(ctx, field, obj)
		case "wireDepositInformation":
			out.Values[i] = ec._CoinbaseWallet_wireDepositInformation(ctx, field, obj)
		case "swiftDepositInformation":
			out.Values[i] = ec._CoinbaseWallet_swiftDepositInformation(ctx, field, obj)
		case "sepaDepositInformation":
			out.Values[i] = ec._CoinbaseWallet_sepaDepositInformation(ctx, field, obj)
		case "ukDepositInformation":
			out.Values[i] = ec._CoinbaseWallet_ukDepositInformation(ctx, field, obj)
		case "destinationTagName":
			out.Values[i] = ec._CoinbaseWallet_destinationTagName(ctx, field, obj)
		case "destinationTagRegex":
			out.Values[i] = ec._CoinbaseWallet_destinationTagRegex(ctx, field, obj)
		case "holdBalance":
			out.Values[i] = ec._CoinbaseWallet_holdBalance(ctx, field, obj)
		case "holdCurrency":
			out.Values[i] = ec._CoinbaseWallet_holdCurrency(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseWireDepositInformationImplementors = []string{"CoinbaseWireDepositInformation"}

func (ec *executionContext) _CoinbaseWireDepositInformation(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseWireDepositInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseWireDepositInformationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseWireDepositInformation")
		case "accountNumber":
			out.Values[i] = ec._CoinbaseWireDepositInformation_accountNumber(ctx, field, obj)
		case "routingNumber":
			out.Values[i] = ec._CoinbaseWireDepositInformation_routingNumber(ctx, field, obj)
		case "bankName":
			out.Values[i] = ec._CoinbaseWireDepositInformation_bankName(ctx, field, obj)
		case "bankAddress":
			out.Values[i] = ec._CoinbaseWireDepositInformation_bankAddress(ctx, field, obj)
		case "bankCountry":
			out.Values[i] = ec._CoinbaseWireDepositInformation_bankCountry(ctx, field, obj)
		case "accountName":
			out.Values[i] = ec._CoinbaseWireDepositInformation_accountName(ctx, field, obj)
		case "accountAddress":
			out.Values[i] = ec._CoinbaseWireDepositInformation_accountAddress(ctx, field, obj)
		case "reference":
			out.Values[i] = ec._CoinbaseWireDepositInformation_reference(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "createCoinbaseLimitOrder":
			out.Values[i] = ec._Mutation_createCoinbaseLimitOrder(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "coinbaseAccountLedger":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseAccountLedger(ctx, field)
				return res
			})
		case "coinbaseAccountHold":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseAccountHold(ctx, field)
				return res
			})
		case "coinbaseAccount":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseAccount(ctx, field)
				return res
			})
		case "coinbaseAccounts":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseAccounts(ctx, field)
				return res
			})
		case "coinbaseAccountTransfer":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseAccountTransfer(ctx, field)
				return res
			})
		case "coinbaseWallets":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseWallets(ctx, field)
				return res
			})
		case "clinbaseClientOrder":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_clinbaseClientOrder(ctx, field)
				return res
			})
		case "coinbaseCurrencies":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseCurrencies(ctx, field)
				return res
			})
		case "coinbaseCurrency":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseCurrency(ctx, field)
				return res
			})
		case "coinbaseOrder":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseOrder(ctx, field)
				return res
			})
		case "coinbaseProducts":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseProducts(ctx, field)
				return res
			})
		case "coinbaseProduct":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseProduct(ctx, field)
				return res
			})
		case "coinbaseProductDailyStats":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseProductDailyStats(ctx, field)
				return res
			})
		case "coinbaseProductHistoricalRate":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseProductHistoricalRate(ctx, field)
				return res
			})
		case "coinbaseProductOrderBook":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseProductOrderBook(ctx, field)
				return res
			})
		case "coinbaseProductTicker":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseProductTicker(ctx, field)
				return res
			})
		case "coinbaseProductTrade":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseProductTrade(ctx, field)
				return res
			})
		case "coinbaseTime":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseTime(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNOrderSide2cqlscalarOrderSide(ctx context.Context, v interface{}) (scalar.OrderSide, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := scalar.OrderSide(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderSide2cqlscalarOrderSide(ctx context.Context, sel ast.SelectionSet, v scalar.OrderSide) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*v)
}

func (ec *executionContext) marshalOCoinbaseAccount2cqlmodelCoinbaseAccount(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseAccount2cqlmodelCoinbaseAccount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseAccount2cqlmodelCoinbaseAccount(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseAccount(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseAccountHold2cqlmodelCoinbaseAccountHold(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseAccountHold) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseAccountHold2cqlmodelCoinbaseAccountHold(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseAccountHold2cqlmodelCoinbaseAccountHold(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseAccountHold) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseAccountHold(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCoinbaseAccountHoldOptions2cqlmodelCoinbaseAccountHoldOptions(ctx context.Context, v interface{}) (*model.CoinbaseAccountHoldOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCoinbaseAccountHoldOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCoinbaseAccountLedger2cqlmodelCoinbaseAccountLedger(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseAccountLedger) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseAccountLedger2cqlmodelCoinbaseAccountLedger(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseAccountLedger2cqlmodelCoinbaseAccountLedger(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseAccountLedger) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseAccountLedger(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseAccountLedgerDetails2cqlmodelCoinbaseAccountLedgerDetails(ctx context.Context, sel ast.SelectionSet, v model.CoinbaseAccountLedgerDetails) graphql.Marshaler {
	return ec._CoinbaseAccountLedgerDetails(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOCoinbaseAccountLedgerOptions2cqlmodelCoinbaseAccountLedgerOptions(ctx context.Context, v interface{}) (*model.CoinbaseAccountLedgerOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCoinbaseAccountLedgerOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCoinbaseAccountTransfer2cqlmodelCoinbaseAccountTransfer(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseAccountTransfer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseAccountTransfer2cqlmodelCoinbaseAccountTransfer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseAccountTransfer2cqlmodelCoinbaseAccountTransfer(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseAccountTransfer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseAccountTransfer(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseAccountTransferDetails2cqlmodelCoinbaseAccountTransferDetails(ctx context.Context, sel ast.SelectionSet, v model.CoinbaseAccountTransferDetails) graphql.Marshaler {
	return ec._CoinbaseAccountTransferDetails(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOCoinbaseAccountTransferOptions2cqlmodelCoinbaseAccountTransferOptions(ctx context.Context, v interface{}) (*model.CoinbaseAccountTransferOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCoinbaseAccountTransferOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCoinbaseBankCountry2cqlmodelCoinbaseBankCountry(ctx context.Context, sel ast.SelectionSet, v model.CoinbaseBankCountry) graphql.Marshaler {
	return ec._CoinbaseBankCountry(ctx, sel, &v)
}

func (ec *executionContext) marshalOCoinbaseCurrency2cqlmodelCoinbaseCurrency(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseCurrency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseCurrency2cqlmodelCoinbaseCurrency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseCurrency2cqlmodelCoinbaseCurrency(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseCurrency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseCurrency(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseCurrencyDetails2cqlmodelCoinbaseCurrencyDetails(ctx context.Context, sel ast.SelectionSet, v model.CoinbaseCurrencyDetails) graphql.Marshaler {
	return ec._CoinbaseCurrencyDetails(ctx, sel, &v)
}

func (ec *executionContext) marshalOCoinbaseOrder2cqlmodelCoinbaseOrder(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseOrder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseOrder(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCoinbaseOrderInput2cqlmodelCoinbaseOrderInput(ctx context.Context, v interface{}) (*model.CoinbaseOrderInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCoinbaseOrderInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCoinbaseProduct2cqlmodelCoinbaseProduct(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseProduct) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseProduct2cqlmodelCoinbaseProduct(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseProduct2cqlmodelCoinbaseProduct(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseProduct) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseProduct(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseProductDailyStats2cqlmodelCoinbaseProductDailyStats(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseProductDailyStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseProductDailyStats(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseProductHistoricalRate2cqlmodelCoinbaseProductHistoricalRate(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseProductHistoricalRate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseProductHistoricalRate2cqlmodelCoinbaseProductHistoricalRate(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseProductHistoricalRate2cqlmodelCoinbaseProductHistoricalRate(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseProductHistoricalRate) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseProductHistoricalRate(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseProductOrderBook2cqlmodelCoinbaseProductOrderBook(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseProductOrderBook) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseProductOrderBook(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseProductOrderBookBidAsk2cqlmodelCoinbaseProductOrderBookBidAsk(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseProductOrderBookBidAsk) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseProductOrderBookBidAsk2cqlmodelCoinbaseProductOrderBookBidAsk(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseProductOrderBookBidAsk2cqlmodelCoinbaseProductOrderBookBidAsk(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseProductOrderBookBidAsk) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseProductOrderBookBidAsk(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseProductTicker2cqlmodelCoinbaseProductTicker(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseProductTicker) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseProductTicker(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseProductTrade2cqlmodelCoinbaseProductTrade(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseProductTrade) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseProductTrade2cqlmodelCoinbaseProductTrade(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseProductTrade2cqlmodelCoinbaseProductTrade(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseProductTrade) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseProductTrade(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseSEPADepositInformation2cqlmodelCoinbaseSEPADepositInformation(ctx context.Context, sel ast.SelectionSet, v model.CoinbaseSEPADepositInformation) graphql.Marshaler {
	return ec._CoinbaseSEPADepositInformation(ctx, sel, &v)
}

func (ec *executionContext) marshalOCoinbaseSWIFTDepositInformation2cqlmodelCoinbaseSWIFTDepositInformation(ctx context.Context, sel ast.SelectionSet, v model.CoinbaseSWIFTDepositInformation) graphql.Marshaler {
	return ec._CoinbaseSWIFTDepositInformation(ctx, sel, &v)
}

func (ec *executionContext) marshalOCoinbaseTime2cqlmodelCoinbaseTime(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseTime(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseUKDepositInformation2cqlmodelCoinbaseUKDepositInformation(ctx context.Context, sel ast.SelectionSet, v model.CoinbaseUKDepositInformation) graphql.Marshaler {
	return ec._CoinbaseUKDepositInformation(ctx, sel, &v)
}

func (ec *executionContext) marshalOCoinbaseWallet2cqlmodelCoinbaseWallet(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseWallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseWallet2cqlmodelCoinbaseWallet(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseWallet2cqlmodelCoinbaseWallet(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseWallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseWallet(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseWireDepositInformation2cqlmodelCoinbaseWireDepositInformation(ctx context.Context, sel ast.SelectionSet, v model.CoinbaseWireDepositInformation) graphql.Marshaler {
	return ec._CoinbaseWireDepositInformation(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOEntryType2cqlscalarEntryType(ctx context.Context, v interface{}) (scalar.EntryType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := scalar.EntryType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEntryType2cqlscalarEntryType(ctx context.Context, sel ast.SelectionSet, v scalar.EntryType) graphql.Marshaler {
	return graphql.MarshalString(string(v))
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*v)
}

func (ec *executionContext) unmarshalOOrderCancelTime2cqlscalarOrderCancelTime(ctx context.Context, v interface{}) (*scalar.OrderCancelTime, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := scalar.OrderCancelTime(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrderCancelTime2cqlscalarOrderCancelTime(ctx context.Context, sel ast.SelectionSet, v *scalar.OrderCancelTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(string(*v))
}

func (ec *executionContext) unmarshalOOrderSTP2cqlscalarOrderSTP(ctx context.Context, v interface{}) (scalar.OrderSTP, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := scalar.OrderSTP(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrderSTP2cqlscalarOrderSTP(ctx context.Context, sel ast.SelectionSet, v scalar.OrderSTP) graphql.Marshaler {
	return graphql.MarshalString(string(v))
}

func (ec *executionContext) unmarshalOOrderSTP2cqlscalarOrderSTP(ctx context.Context, v interface{}) (*scalar.OrderSTP, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := scalar.OrderSTP(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrderSTP2cqlscalarOrderSTP(ctx context.Context, sel ast.SelectionSet, v *scalar.OrderSTP) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(string(*v))
}

func (ec *executionContext) unmarshalOOrderSide2cqlscalarOrderSide(ctx context.Context, v interface{}) (scalar.OrderSide, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := scalar.OrderSide(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrderSide2cqlscalarOrderSide(ctx context.Context, sel ast.SelectionSet, v scalar.OrderSide) graphql.Marshaler {
	return graphql.MarshalString(string(v))
}

func (ec *executionContext) unmarshalOOrderStop2cqlscalarOrderSide(ctx context.Context, v interface{}) (*scalar.OrderSide, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := scalar.OrderSide(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrderStop2cqlscalarOrderSide(ctx context.Context, sel ast.SelectionSet, v *scalar.OrderSide) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(string(*v))
}

func (ec *executionContext) unmarshalOOrderType2cqlscalarOrderType(ctx context.Context, v interface{}) (scalar.OrderType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := scalar.OrderType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOrderType2cqlscalarOrderType(ctx context.Context, sel ast.SelectionSet, v scalar.OrderType) graphql.Marshaler {
	return graphql.MarshalString(string(v))
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	return graphql.MarshalTime(v)
}

func (ec *executionContext) unmarshalOTimeInForce2cqlscalarTimeInForce(ctx context.Context, v interface{}) (scalar.TimeInForce, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := scalar.TimeInForce(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTimeInForce2cqlscalarTimeInForce(ctx context.Context, sel ast.SelectionSet, v scalar.TimeInForce) graphql.Marshaler {
	return graphql.MarshalString(string(v))
}

func (ec *executionContext) unmarshalOTimeInForce2cqlscalarTimeInForce(ctx context.Context, v interface{}) (*scalar.TimeInForce, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := scalar.TimeInForce(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTimeInForce2cqlscalarTimeInForce(ctx context.Context, sel ast.SelectionSet, v *scalar.TimeInForce) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(string(*v))
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
