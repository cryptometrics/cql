// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"cql/model"
	"cql/scalar"
	"errors"
	"strconv"
	"sync"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	CoinbaseAccount struct {
		Available      func(childComplexity int) int
		Balance        func(childComplexity int) int
		Currency       func(childComplexity int) int
		Hold           func(childComplexity int) int
		Id             func(childComplexity int) int
		ProfileId      func(childComplexity int) int
		TradingEnabled func(childComplexity int) int
	}

	CoinbaseAccountHold struct {
		CreatedAt func(childComplexity int) int
		Id        func(childComplexity int) int
		Ref       func(childComplexity int) int
		Type      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	CoinbaseAccountLedger struct {
		Amount    func(childComplexity int) int
		Balance   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Details   func(childComplexity int) int
		Id        func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	CoinbaseAccountLedgerDetails struct {
		OrderId   func(childComplexity int) int
		ProductId func(childComplexity int) int
		TradeId   func(childComplexity int) int
	}

	CoinbaseAccountTransfer struct {
		Amount      func(childComplexity int) int
		CanceledAt  func(childComplexity int) int
		CompletedAt func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Details     func(childComplexity int) int
		Id          func(childComplexity int) int
		ProcessedAt func(childComplexity int) int
		Type        func(childComplexity int) int
		UserNonce   func(childComplexity int) int
	}

	CoinbaseAccountTransferDetails struct {
		CoinbaseAccountId       func(childComplexity int) int
		CoinbasePaymentMethodId func(childComplexity int) int
		CoinbaseTransactionId   func(childComplexity int) int
	}

	CoinbaseBankCountry struct {
		Code func(childComplexity int) int
		Name func(childComplexity int) int
	}

	CoinbaseCryptoAddress struct {
		Address        func(childComplexity int) int
		AddressInfo    func(childComplexity int) int
		CallbackUrl    func(childComplexity int) int
		CreateAt       func(childComplexity int) int
		DepositUri     func(childComplexity int) int
		DestinationTag func(childComplexity int) int
		Id             func(childComplexity int) int
		LegacyAddress  func(childComplexity int) int
		Name           func(childComplexity int) int
		Network        func(childComplexity int) int
		Resource       func(childComplexity int) int
		ResourcePath   func(childComplexity int) int
		UpdatedAt      func(childComplexity int) int
		UriScheme      func(childComplexity int) int
		Warnings       func(childComplexity int) int
	}

	CoinbaseCryptoAddressInfo struct {
		Address        func(childComplexity int) int
		DestinationTag func(childComplexity int) int
	}

	CoinbaseCryptoAddressWarning struct {
		Details  func(childComplexity int) int
		ImageUrl func(childComplexity int) int
		Title    func(childComplexity int) int
	}

	CoinbaseCurrency struct {
		ConvertibleTo func(childComplexity int) int
		Details       func(childComplexity int) int
		Id            func(childComplexity int) int
		MaxPrecision  func(childComplexity int) int
		Message       func(childComplexity int) int
		MinSize       func(childComplexity int) int
		Name          func(childComplexity int) int
		Status        func(childComplexity int) int
	}

	CoinbaseCurrencyConversion struct {
		Amount        func(childComplexity int) int
		From          func(childComplexity int) int
		FromAccountId func(childComplexity int) int
		Id            func(childComplexity int) int
		To            func(childComplexity int) int
		ToAccountId   func(childComplexity int) int
	}

	CoinbaseCurrencyDetails struct {
		CryptoAddressLink     func(childComplexity int) int
		CryptoTransactionLink func(childComplexity int) int
		DisplayName           func(childComplexity int) int
		GroupTypes            func(childComplexity int) int
		MaxWithdrawalAmount   func(childComplexity int) int
		MinWithdrawalAmount   func(childComplexity int) int
		NetworkConfirmations  func(childComplexity int) int
		ProcessingTimeSeconds func(childComplexity int) int
		PushPaymentMethods    func(childComplexity int) int
		SortOrder             func(childComplexity int) int
		Symbol                func(childComplexity int) int
		Type                  func(childComplexity int) int
	}

	CoinbaseSepaDepositInformation struct {
		AccountAddress func(childComplexity int) int
		AccountName    func(childComplexity int) int
		BankAddress    func(childComplexity int) int
		BankCountry    func(childComplexity int) int
		BankName       func(childComplexity int) int
		Iban           func(childComplexity int) int
		Reference      func(childComplexity int) int
		Swift          func(childComplexity int) int
	}

	CoinbaseSwiftDepositInformation struct {
		AccountAddress func(childComplexity int) int
		AccountName    func(childComplexity int) int
		AccountNumber  func(childComplexity int) int
		BankAddress    func(childComplexity int) int
		BankCountry    func(childComplexity int) int
		BankName       func(childComplexity int) int
		Reference      func(childComplexity int) int
	}

	CoinbaseUkDepositInformation struct {
		AccountAddress func(childComplexity int) int
		AccountName    func(childComplexity int) int
		AccountNumber  func(childComplexity int) int
		BankAddress    func(childComplexity int) int
		BankCountry    func(childComplexity int) int
		BankName       func(childComplexity int) int
		Reference      func(childComplexity int) int
	}

	CoinbaseWallet struct {
		Active                  func(childComplexity int) int
		AvailableOnConsumer     func(childComplexity int) int
		Balance                 func(childComplexity int) int
		Currency                func(childComplexity int) int
		DestinationTagName      func(childComplexity int) int
		DestinationTagRegex     func(childComplexity int) int
		HoldBalance             func(childComplexity int) int
		HoldCurrency            func(childComplexity int) int
		Id                      func(childComplexity int) int
		Name                    func(childComplexity int) int
		Primary                 func(childComplexity int) int
		Ready                   func(childComplexity int) int
		SepaDepositInformation  func(childComplexity int) int
		SwiftDepositInformation func(childComplexity int) int
		Type                    func(childComplexity int) int
		UkDepositInformation    func(childComplexity int) int
		WireDepositInformation  func(childComplexity int) int
	}

	CoinbaseWireDepositInformation struct {
		AccountAddress func(childComplexity int) int
		AccountName    func(childComplexity int) int
		AccountNumber  func(childComplexity int) int
		BankAddress    func(childComplexity int) int
		BankCountry    func(childComplexity int) int
		BankName       func(childComplexity int) int
		Reference      func(childComplexity int) int
		RoutingNumber  func(childComplexity int) int
	}

	IexRule struct {
		Formula func(childComplexity int) int
		Label   func(childComplexity int) int
		Scope   func(childComplexity int) int
		Type    func(childComplexity int) int
		Value   func(childComplexity int) int
	}

	IexRulesSchema struct {
		Schema func(childComplexity int) int
	}

	IexRulesScheme struct {
		IsLookup  func(childComplexity int) int
		Label     func(childComplexity int) int
		Scope     func(childComplexity int) int
		Type      func(childComplexity int) int
		Value     func(childComplexity int) int
		Weight    func(childComplexity int) int
		WeightKey func(childComplexity int) int
	}

	KrakenServerTime struct {
		Error  func(childComplexity int) int
		Result func(childComplexity int) int
	}

	KrakenServerTimeResult struct {
		Rfc1123  func(childComplexity int) int
		Unixtime func(childComplexity int) int
	}

	KrakenSystemStatus struct {
		Error  func(childComplexity int) int
		Result func(childComplexity int) int
	}

	KrakenSystemStatusResult struct {
		Status    func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	Mutation struct {
		CoinbaseConvertCurrency       func(childComplexity int, opts model.CoinbaseConversionsOptions) int
		CoinbaseGenerateCryptoAddress func(childComplexity int, walletID string) int
	}

	Query struct {
		CoinbaseAccount            func(childComplexity int, accountID string) int
		CoinbaseAccountHolds       func(childComplexity int, accountID string, opts *model.CoinbaseAccountHoldsOptions) int
		CoinbaseAccountLedger      func(childComplexity int, accountID string, opts *model.CoinbaseAccountLedgerOptions) int
		CoinbaseAccountTransfers   func(childComplexity int, accountID string, opts *model.CoinbaseAccountTransferOptions) int
		CoinbaseAccounts           func(childComplexity int) int
		CoinbaseCurrencies         func(childComplexity int) int
		CoinbaseCurrency           func(childComplexity int, currentID string) int
		CoinbaseCurrencyConversion func(childComplexity int, conversionID string, opts *model.CoinbaseConversionOptions) int
		CoinbaseWallets            func(childComplexity int) int
		IexRules                   func(childComplexity int, value string) int
		IexRulesSchema             func(childComplexity int) int
		KrakenServerTime           func(childComplexity int) int
		KrakenSystemStatus         func(childComplexity int) int
	}
}

type MutationResolver interface {
	CoinbaseConvertCurrency(ctx context.Context, opts model.CoinbaseConversionsOptions) (*model.CoinbaseCurrencyConversion, error)
	CoinbaseGenerateCryptoAddress(ctx context.Context, walletID string) (*model.CoinbaseCryptoAddress, error)
}
type QueryResolver interface {
	CoinbaseAccount(ctx context.Context, accountID string) (*model.CoinbaseAccount, error)
	CoinbaseAccounts(ctx context.Context) ([]*model.CoinbaseAccount, error)
	CoinbaseAccountHolds(ctx context.Context, accountID string, opts *model.CoinbaseAccountHoldsOptions) ([]*model.CoinbaseAccountHold, error)
	CoinbaseAccountLedger(ctx context.Context, accountID string, opts *model.CoinbaseAccountLedgerOptions) ([]*model.CoinbaseAccountLedger, error)
	CoinbaseAccountTransfers(ctx context.Context, accountID string, opts *model.CoinbaseAccountTransferOptions) ([]*model.CoinbaseAccountTransfer, error)
	CoinbaseCurrencies(ctx context.Context) ([]*model.CoinbaseCurrency, error)
	CoinbaseCurrencyConversion(ctx context.Context, conversionID string, opts *model.CoinbaseConversionOptions) (*model.CoinbaseCurrencyConversion, error)
	CoinbaseCurrency(ctx context.Context, currentID string) (*model.CoinbaseCurrency, error)
	CoinbaseWallets(ctx context.Context) ([]*model.CoinbaseWallet, error)
	IexRules(ctx context.Context, value string) ([]*model.IexRule, error)
	IexRulesSchema(ctx context.Context) (*model.IexRulesSchema, error)
	KrakenServerTime(ctx context.Context) (*model.KrakenServerTime, error)
	KrakenSystemStatus(ctx context.Context) (*model.KrakenSystemStatus, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "CoinbaseAccount.available":
		if e.complexity.CoinbaseAccount.Available == nil {
			break
		}

		return e.complexity.CoinbaseAccount.Available(childComplexity), true

	case "CoinbaseAccount.balance":
		if e.complexity.CoinbaseAccount.Balance == nil {
			break
		}

		return e.complexity.CoinbaseAccount.Balance(childComplexity), true

	case "CoinbaseAccount.currency":
		if e.complexity.CoinbaseAccount.Currency == nil {
			break
		}

		return e.complexity.CoinbaseAccount.Currency(childComplexity), true

	case "CoinbaseAccount.hold":
		if e.complexity.CoinbaseAccount.Hold == nil {
			break
		}

		return e.complexity.CoinbaseAccount.Hold(childComplexity), true

	case "CoinbaseAccount.id":
		if e.complexity.CoinbaseAccount.Id == nil {
			break
		}

		return e.complexity.CoinbaseAccount.Id(childComplexity), true

	case "CoinbaseAccount.profileId":
		if e.complexity.CoinbaseAccount.ProfileId == nil {
			break
		}

		return e.complexity.CoinbaseAccount.ProfileId(childComplexity), true

	case "CoinbaseAccount.tradingEnabled":
		if e.complexity.CoinbaseAccount.TradingEnabled == nil {
			break
		}

		return e.complexity.CoinbaseAccount.TradingEnabled(childComplexity), true

	case "CoinbaseAccountHold.createdAt":
		if e.complexity.CoinbaseAccountHold.CreatedAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountHold.CreatedAt(childComplexity), true

	case "CoinbaseAccountHold.id":
		if e.complexity.CoinbaseAccountHold.Id == nil {
			break
		}

		return e.complexity.CoinbaseAccountHold.Id(childComplexity), true

	case "CoinbaseAccountHold.ref":
		if e.complexity.CoinbaseAccountHold.Ref == nil {
			break
		}

		return e.complexity.CoinbaseAccountHold.Ref(childComplexity), true

	case "CoinbaseAccountHold.type":
		if e.complexity.CoinbaseAccountHold.Type == nil {
			break
		}

		return e.complexity.CoinbaseAccountHold.Type(childComplexity), true

	case "CoinbaseAccountHold.updatedAt":
		if e.complexity.CoinbaseAccountHold.UpdatedAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountHold.UpdatedAt(childComplexity), true

	case "CoinbaseAccountLedger.amount":
		if e.complexity.CoinbaseAccountLedger.Amount == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedger.Amount(childComplexity), true

	case "CoinbaseAccountLedger.balance":
		if e.complexity.CoinbaseAccountLedger.Balance == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedger.Balance(childComplexity), true

	case "CoinbaseAccountLedger.createdAt":
		if e.complexity.CoinbaseAccountLedger.CreatedAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedger.CreatedAt(childComplexity), true

	case "CoinbaseAccountLedger.details":
		if e.complexity.CoinbaseAccountLedger.Details == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedger.Details(childComplexity), true

	case "CoinbaseAccountLedger.id":
		if e.complexity.CoinbaseAccountLedger.Id == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedger.Id(childComplexity), true

	case "CoinbaseAccountLedger.type":
		if e.complexity.CoinbaseAccountLedger.Type == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedger.Type(childComplexity), true

	case "CoinbaseAccountLedgerDetails.orderId":
		if e.complexity.CoinbaseAccountLedgerDetails.OrderId == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedgerDetails.OrderId(childComplexity), true

	case "CoinbaseAccountLedgerDetails.productId":
		if e.complexity.CoinbaseAccountLedgerDetails.ProductId == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedgerDetails.ProductId(childComplexity), true

	case "CoinbaseAccountLedgerDetails.tradeId":
		if e.complexity.CoinbaseAccountLedgerDetails.TradeId == nil {
			break
		}

		return e.complexity.CoinbaseAccountLedgerDetails.TradeId(childComplexity), true

	case "CoinbaseAccountTransfer.amount":
		if e.complexity.CoinbaseAccountTransfer.Amount == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.Amount(childComplexity), true

	case "CoinbaseAccountTransfer.canceledAt":
		if e.complexity.CoinbaseAccountTransfer.CanceledAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.CanceledAt(childComplexity), true

	case "CoinbaseAccountTransfer.completedAt":
		if e.complexity.CoinbaseAccountTransfer.CompletedAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.CompletedAt(childComplexity), true

	case "CoinbaseAccountTransfer.createdAt":
		if e.complexity.CoinbaseAccountTransfer.CreatedAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.CreatedAt(childComplexity), true

	case "CoinbaseAccountTransfer.details":
		if e.complexity.CoinbaseAccountTransfer.Details == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.Details(childComplexity), true

	case "CoinbaseAccountTransfer.id":
		if e.complexity.CoinbaseAccountTransfer.Id == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.Id(childComplexity), true

	case "CoinbaseAccountTransfer.processedAt":
		if e.complexity.CoinbaseAccountTransfer.ProcessedAt == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.ProcessedAt(childComplexity), true

	case "CoinbaseAccountTransfer.type":
		if e.complexity.CoinbaseAccountTransfer.Type == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.Type(childComplexity), true

	case "CoinbaseAccountTransfer.userNonce":
		if e.complexity.CoinbaseAccountTransfer.UserNonce == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransfer.UserNonce(childComplexity), true

	case "CoinbaseAccountTransferDetails.coinbaseAccountId":
		if e.complexity.CoinbaseAccountTransferDetails.CoinbaseAccountId == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransferDetails.CoinbaseAccountId(childComplexity), true

	case "CoinbaseAccountTransferDetails.coinbasePaymentMethodId":
		if e.complexity.CoinbaseAccountTransferDetails.CoinbasePaymentMethodId == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransferDetails.CoinbasePaymentMethodId(childComplexity), true

	case "CoinbaseAccountTransferDetails.coinbaseTransactionId":
		if e.complexity.CoinbaseAccountTransferDetails.CoinbaseTransactionId == nil {
			break
		}

		return e.complexity.CoinbaseAccountTransferDetails.CoinbaseTransactionId(childComplexity), true

	case "CoinbaseBankCountry.code":
		if e.complexity.CoinbaseBankCountry.Code == nil {
			break
		}

		return e.complexity.CoinbaseBankCountry.Code(childComplexity), true

	case "CoinbaseBankCountry.name":
		if e.complexity.CoinbaseBankCountry.Name == nil {
			break
		}

		return e.complexity.CoinbaseBankCountry.Name(childComplexity), true

	case "CoinbaseCryptoAddress.address":
		if e.complexity.CoinbaseCryptoAddress.Address == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.Address(childComplexity), true

	case "CoinbaseCryptoAddress.addressInfo":
		if e.complexity.CoinbaseCryptoAddress.AddressInfo == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.AddressInfo(childComplexity), true

	case "CoinbaseCryptoAddress.callbackUrl":
		if e.complexity.CoinbaseCryptoAddress.CallbackUrl == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.CallbackUrl(childComplexity), true

	case "CoinbaseCryptoAddress.createAt":
		if e.complexity.CoinbaseCryptoAddress.CreateAt == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.CreateAt(childComplexity), true

	case "CoinbaseCryptoAddress.depositUri":
		if e.complexity.CoinbaseCryptoAddress.DepositUri == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.DepositUri(childComplexity), true

	case "CoinbaseCryptoAddress.destinationTag":
		if e.complexity.CoinbaseCryptoAddress.DestinationTag == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.DestinationTag(childComplexity), true

	case "CoinbaseCryptoAddress.id":
		if e.complexity.CoinbaseCryptoAddress.Id == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.Id(childComplexity), true

	case "CoinbaseCryptoAddress.legacyAddress":
		if e.complexity.CoinbaseCryptoAddress.LegacyAddress == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.LegacyAddress(childComplexity), true

	case "CoinbaseCryptoAddress.name":
		if e.complexity.CoinbaseCryptoAddress.Name == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.Name(childComplexity), true

	case "CoinbaseCryptoAddress.network":
		if e.complexity.CoinbaseCryptoAddress.Network == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.Network(childComplexity), true

	case "CoinbaseCryptoAddress.resource":
		if e.complexity.CoinbaseCryptoAddress.Resource == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.Resource(childComplexity), true

	case "CoinbaseCryptoAddress.resourcePath":
		if e.complexity.CoinbaseCryptoAddress.ResourcePath == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.ResourcePath(childComplexity), true

	case "CoinbaseCryptoAddress.updatedAt":
		if e.complexity.CoinbaseCryptoAddress.UpdatedAt == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.UpdatedAt(childComplexity), true

	case "CoinbaseCryptoAddress.uriScheme":
		if e.complexity.CoinbaseCryptoAddress.UriScheme == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.UriScheme(childComplexity), true

	case "CoinbaseCryptoAddress.warnings":
		if e.complexity.CoinbaseCryptoAddress.Warnings == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddress.Warnings(childComplexity), true

	case "CoinbaseCryptoAddressInfo.address":
		if e.complexity.CoinbaseCryptoAddressInfo.Address == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddressInfo.Address(childComplexity), true

	case "CoinbaseCryptoAddressInfo.destinationTag":
		if e.complexity.CoinbaseCryptoAddressInfo.DestinationTag == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddressInfo.DestinationTag(childComplexity), true

	case "CoinbaseCryptoAddressWarning.details":
		if e.complexity.CoinbaseCryptoAddressWarning.Details == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddressWarning.Details(childComplexity), true

	case "CoinbaseCryptoAddressWarning.imageUrl":
		if e.complexity.CoinbaseCryptoAddressWarning.ImageUrl == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddressWarning.ImageUrl(childComplexity), true

	case "CoinbaseCryptoAddressWarning.title":
		if e.complexity.CoinbaseCryptoAddressWarning.Title == nil {
			break
		}

		return e.complexity.CoinbaseCryptoAddressWarning.Title(childComplexity), true

	case "CoinbaseCurrency.convertibleTo":
		if e.complexity.CoinbaseCurrency.ConvertibleTo == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.ConvertibleTo(childComplexity), true

	case "CoinbaseCurrency.details":
		if e.complexity.CoinbaseCurrency.Details == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.Details(childComplexity), true

	case "CoinbaseCurrency.id":
		if e.complexity.CoinbaseCurrency.Id == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.Id(childComplexity), true

	case "CoinbaseCurrency.maxPrecision":
		if e.complexity.CoinbaseCurrency.MaxPrecision == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.MaxPrecision(childComplexity), true

	case "CoinbaseCurrency.message":
		if e.complexity.CoinbaseCurrency.Message == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.Message(childComplexity), true

	case "CoinbaseCurrency.minSize":
		if e.complexity.CoinbaseCurrency.MinSize == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.MinSize(childComplexity), true

	case "CoinbaseCurrency.name":
		if e.complexity.CoinbaseCurrency.Name == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.Name(childComplexity), true

	case "CoinbaseCurrency.status":
		if e.complexity.CoinbaseCurrency.Status == nil {
			break
		}

		return e.complexity.CoinbaseCurrency.Status(childComplexity), true

	case "CoinbaseCurrencyConversion.amount":
		if e.complexity.CoinbaseCurrencyConversion.Amount == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyConversion.Amount(childComplexity), true

	case "CoinbaseCurrencyConversion.from":
		if e.complexity.CoinbaseCurrencyConversion.From == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyConversion.From(childComplexity), true

	case "CoinbaseCurrencyConversion.fromAccountId":
		if e.complexity.CoinbaseCurrencyConversion.FromAccountId == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyConversion.FromAccountId(childComplexity), true

	case "CoinbaseCurrencyConversion.id":
		if e.complexity.CoinbaseCurrencyConversion.Id == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyConversion.Id(childComplexity), true

	case "CoinbaseCurrencyConversion.to":
		if e.complexity.CoinbaseCurrencyConversion.To == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyConversion.To(childComplexity), true

	case "CoinbaseCurrencyConversion.toAccountId":
		if e.complexity.CoinbaseCurrencyConversion.ToAccountId == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyConversion.ToAccountId(childComplexity), true

	case "CoinbaseCurrencyDetails.cryptoAddressLink":
		if e.complexity.CoinbaseCurrencyDetails.CryptoAddressLink == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.CryptoAddressLink(childComplexity), true

	case "CoinbaseCurrencyDetails.cryptoTransactionLink":
		if e.complexity.CoinbaseCurrencyDetails.CryptoTransactionLink == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.CryptoTransactionLink(childComplexity), true

	case "CoinbaseCurrencyDetails.displayName":
		if e.complexity.CoinbaseCurrencyDetails.DisplayName == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.DisplayName(childComplexity), true

	case "CoinbaseCurrencyDetails.groupTypes":
		if e.complexity.CoinbaseCurrencyDetails.GroupTypes == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.GroupTypes(childComplexity), true

	case "CoinbaseCurrencyDetails.maxWithdrawalAmount":
		if e.complexity.CoinbaseCurrencyDetails.MaxWithdrawalAmount == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.MaxWithdrawalAmount(childComplexity), true

	case "CoinbaseCurrencyDetails.minWithdrawalAmount":
		if e.complexity.CoinbaseCurrencyDetails.MinWithdrawalAmount == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.MinWithdrawalAmount(childComplexity), true

	case "CoinbaseCurrencyDetails.networkConfirmations":
		if e.complexity.CoinbaseCurrencyDetails.NetworkConfirmations == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.NetworkConfirmations(childComplexity), true

	case "CoinbaseCurrencyDetails.processingTimeSeconds":
		if e.complexity.CoinbaseCurrencyDetails.ProcessingTimeSeconds == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.ProcessingTimeSeconds(childComplexity), true

	case "CoinbaseCurrencyDetails.pushPaymentMethods":
		if e.complexity.CoinbaseCurrencyDetails.PushPaymentMethods == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.PushPaymentMethods(childComplexity), true

	case "CoinbaseCurrencyDetails.sortOrder":
		if e.complexity.CoinbaseCurrencyDetails.SortOrder == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.SortOrder(childComplexity), true

	case "CoinbaseCurrencyDetails.symbol":
		if e.complexity.CoinbaseCurrencyDetails.Symbol == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.Symbol(childComplexity), true

	case "CoinbaseCurrencyDetails.type":
		if e.complexity.CoinbaseCurrencyDetails.Type == nil {
			break
		}

		return e.complexity.CoinbaseCurrencyDetails.Type(childComplexity), true

	case "CoinbaseSepaDepositInformation.accountAddress":
		if e.complexity.CoinbaseSepaDepositInformation.AccountAddress == nil {
			break
		}

		return e.complexity.CoinbaseSepaDepositInformation.AccountAddress(childComplexity), true

	case "CoinbaseSepaDepositInformation.accountName":
		if e.complexity.CoinbaseSepaDepositInformation.AccountName == nil {
			break
		}

		return e.complexity.CoinbaseSepaDepositInformation.AccountName(childComplexity), true

	case "CoinbaseSepaDepositInformation.bankAddress":
		if e.complexity.CoinbaseSepaDepositInformation.BankAddress == nil {
			break
		}

		return e.complexity.CoinbaseSepaDepositInformation.BankAddress(childComplexity), true

	case "CoinbaseSepaDepositInformation.bankCountry":
		if e.complexity.CoinbaseSepaDepositInformation.BankCountry == nil {
			break
		}

		return e.complexity.CoinbaseSepaDepositInformation.BankCountry(childComplexity), true

	case "CoinbaseSepaDepositInformation.bankName":
		if e.complexity.CoinbaseSepaDepositInformation.BankName == nil {
			break
		}

		return e.complexity.CoinbaseSepaDepositInformation.BankName(childComplexity), true

	case "CoinbaseSepaDepositInformation.iban":
		if e.complexity.CoinbaseSepaDepositInformation.Iban == nil {
			break
		}

		return e.complexity.CoinbaseSepaDepositInformation.Iban(childComplexity), true

	case "CoinbaseSepaDepositInformation.reference":
		if e.complexity.CoinbaseSepaDepositInformation.Reference == nil {
			break
		}

		return e.complexity.CoinbaseSepaDepositInformation.Reference(childComplexity), true

	case "CoinbaseSepaDepositInformation.swift":
		if e.complexity.CoinbaseSepaDepositInformation.Swift == nil {
			break
		}

		return e.complexity.CoinbaseSepaDepositInformation.Swift(childComplexity), true

	case "CoinbaseSwiftDepositInformation.accountAddress":
		if e.complexity.CoinbaseSwiftDepositInformation.AccountAddress == nil {
			break
		}

		return e.complexity.CoinbaseSwiftDepositInformation.AccountAddress(childComplexity), true

	case "CoinbaseSwiftDepositInformation.accountName":
		if e.complexity.CoinbaseSwiftDepositInformation.AccountName == nil {
			break
		}

		return e.complexity.CoinbaseSwiftDepositInformation.AccountName(childComplexity), true

	case "CoinbaseSwiftDepositInformation.accountNumber":
		if e.complexity.CoinbaseSwiftDepositInformation.AccountNumber == nil {
			break
		}

		return e.complexity.CoinbaseSwiftDepositInformation.AccountNumber(childComplexity), true

	case "CoinbaseSwiftDepositInformation.bankAddress":
		if e.complexity.CoinbaseSwiftDepositInformation.BankAddress == nil {
			break
		}

		return e.complexity.CoinbaseSwiftDepositInformation.BankAddress(childComplexity), true

	case "CoinbaseSwiftDepositInformation.bankCountry":
		if e.complexity.CoinbaseSwiftDepositInformation.BankCountry == nil {
			break
		}

		return e.complexity.CoinbaseSwiftDepositInformation.BankCountry(childComplexity), true

	case "CoinbaseSwiftDepositInformation.bankName":
		if e.complexity.CoinbaseSwiftDepositInformation.BankName == nil {
			break
		}

		return e.complexity.CoinbaseSwiftDepositInformation.BankName(childComplexity), true

	case "CoinbaseSwiftDepositInformation.reference":
		if e.complexity.CoinbaseSwiftDepositInformation.Reference == nil {
			break
		}

		return e.complexity.CoinbaseSwiftDepositInformation.Reference(childComplexity), true

	case "CoinbaseUkDepositInformation.accountAddress":
		if e.complexity.CoinbaseUkDepositInformation.AccountAddress == nil {
			break
		}

		return e.complexity.CoinbaseUkDepositInformation.AccountAddress(childComplexity), true

	case "CoinbaseUkDepositInformation.accountName":
		if e.complexity.CoinbaseUkDepositInformation.AccountName == nil {
			break
		}

		return e.complexity.CoinbaseUkDepositInformation.AccountName(childComplexity), true

	case "CoinbaseUkDepositInformation.accountNumber":
		if e.complexity.CoinbaseUkDepositInformation.AccountNumber == nil {
			break
		}

		return e.complexity.CoinbaseUkDepositInformation.AccountNumber(childComplexity), true

	case "CoinbaseUkDepositInformation.bankAddress":
		if e.complexity.CoinbaseUkDepositInformation.BankAddress == nil {
			break
		}

		return e.complexity.CoinbaseUkDepositInformation.BankAddress(childComplexity), true

	case "CoinbaseUkDepositInformation.bankCountry":
		if e.complexity.CoinbaseUkDepositInformation.BankCountry == nil {
			break
		}

		return e.complexity.CoinbaseUkDepositInformation.BankCountry(childComplexity), true

	case "CoinbaseUkDepositInformation.bankName":
		if e.complexity.CoinbaseUkDepositInformation.BankName == nil {
			break
		}

		return e.complexity.CoinbaseUkDepositInformation.BankName(childComplexity), true

	case "CoinbaseUkDepositInformation.reference":
		if e.complexity.CoinbaseUkDepositInformation.Reference == nil {
			break
		}

		return e.complexity.CoinbaseUkDepositInformation.Reference(childComplexity), true

	case "CoinbaseWallet.active":
		if e.complexity.CoinbaseWallet.Active == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Active(childComplexity), true

	case "CoinbaseWallet.availableOnConsumer":
		if e.complexity.CoinbaseWallet.AvailableOnConsumer == nil {
			break
		}

		return e.complexity.CoinbaseWallet.AvailableOnConsumer(childComplexity), true

	case "CoinbaseWallet.balance":
		if e.complexity.CoinbaseWallet.Balance == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Balance(childComplexity), true

	case "CoinbaseWallet.currency":
		if e.complexity.CoinbaseWallet.Currency == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Currency(childComplexity), true

	case "CoinbaseWallet.destinationTagName":
		if e.complexity.CoinbaseWallet.DestinationTagName == nil {
			break
		}

		return e.complexity.CoinbaseWallet.DestinationTagName(childComplexity), true

	case "CoinbaseWallet.destinationTagRegex":
		if e.complexity.CoinbaseWallet.DestinationTagRegex == nil {
			break
		}

		return e.complexity.CoinbaseWallet.DestinationTagRegex(childComplexity), true

	case "CoinbaseWallet.holdBalance":
		if e.complexity.CoinbaseWallet.HoldBalance == nil {
			break
		}

		return e.complexity.CoinbaseWallet.HoldBalance(childComplexity), true

	case "CoinbaseWallet.holdCurrency":
		if e.complexity.CoinbaseWallet.HoldCurrency == nil {
			break
		}

		return e.complexity.CoinbaseWallet.HoldCurrency(childComplexity), true

	case "CoinbaseWallet.id":
		if e.complexity.CoinbaseWallet.Id == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Id(childComplexity), true

	case "CoinbaseWallet.name":
		if e.complexity.CoinbaseWallet.Name == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Name(childComplexity), true

	case "CoinbaseWallet.primary":
		if e.complexity.CoinbaseWallet.Primary == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Primary(childComplexity), true

	case "CoinbaseWallet.ready":
		if e.complexity.CoinbaseWallet.Ready == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Ready(childComplexity), true

	case "CoinbaseWallet.sepaDepositInformation":
		if e.complexity.CoinbaseWallet.SepaDepositInformation == nil {
			break
		}

		return e.complexity.CoinbaseWallet.SepaDepositInformation(childComplexity), true

	case "CoinbaseWallet.swiftDepositInformation":
		if e.complexity.CoinbaseWallet.SwiftDepositInformation == nil {
			break
		}

		return e.complexity.CoinbaseWallet.SwiftDepositInformation(childComplexity), true

	case "CoinbaseWallet.type":
		if e.complexity.CoinbaseWallet.Type == nil {
			break
		}

		return e.complexity.CoinbaseWallet.Type(childComplexity), true

	case "CoinbaseWallet.ukDepositInformation":
		if e.complexity.CoinbaseWallet.UkDepositInformation == nil {
			break
		}

		return e.complexity.CoinbaseWallet.UkDepositInformation(childComplexity), true

	case "CoinbaseWallet.wireDepositInformation":
		if e.complexity.CoinbaseWallet.WireDepositInformation == nil {
			break
		}

		return e.complexity.CoinbaseWallet.WireDepositInformation(childComplexity), true

	case "CoinbaseWireDepositInformation.accountAddress":
		if e.complexity.CoinbaseWireDepositInformation.AccountAddress == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.AccountAddress(childComplexity), true

	case "CoinbaseWireDepositInformation.accountName":
		if e.complexity.CoinbaseWireDepositInformation.AccountName == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.AccountName(childComplexity), true

	case "CoinbaseWireDepositInformation.accountNumber":
		if e.complexity.CoinbaseWireDepositInformation.AccountNumber == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.AccountNumber(childComplexity), true

	case "CoinbaseWireDepositInformation.bankAddress":
		if e.complexity.CoinbaseWireDepositInformation.BankAddress == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.BankAddress(childComplexity), true

	case "CoinbaseWireDepositInformation.bankCountry":
		if e.complexity.CoinbaseWireDepositInformation.BankCountry == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.BankCountry(childComplexity), true

	case "CoinbaseWireDepositInformation.bankName":
		if e.complexity.CoinbaseWireDepositInformation.BankName == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.BankName(childComplexity), true

	case "CoinbaseWireDepositInformation.reference":
		if e.complexity.CoinbaseWireDepositInformation.Reference == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.Reference(childComplexity), true

	case "CoinbaseWireDepositInformation.routingNumber":
		if e.complexity.CoinbaseWireDepositInformation.RoutingNumber == nil {
			break
		}

		return e.complexity.CoinbaseWireDepositInformation.RoutingNumber(childComplexity), true

	case "IexRule.formula":
		if e.complexity.IexRule.Formula == nil {
			break
		}

		return e.complexity.IexRule.Formula(childComplexity), true

	case "IexRule.label":
		if e.complexity.IexRule.Label == nil {
			break
		}

		return e.complexity.IexRule.Label(childComplexity), true

	case "IexRule.scope":
		if e.complexity.IexRule.Scope == nil {
			break
		}

		return e.complexity.IexRule.Scope(childComplexity), true

	case "IexRule.type":
		if e.complexity.IexRule.Type == nil {
			break
		}

		return e.complexity.IexRule.Type(childComplexity), true

	case "IexRule.value":
		if e.complexity.IexRule.Value == nil {
			break
		}

		return e.complexity.IexRule.Value(childComplexity), true

	case "IexRulesSchema.schema":
		if e.complexity.IexRulesSchema.Schema == nil {
			break
		}

		return e.complexity.IexRulesSchema.Schema(childComplexity), true

	case "IexRulesScheme.isLookup":
		if e.complexity.IexRulesScheme.IsLookup == nil {
			break
		}

		return e.complexity.IexRulesScheme.IsLookup(childComplexity), true

	case "IexRulesScheme.label":
		if e.complexity.IexRulesScheme.Label == nil {
			break
		}

		return e.complexity.IexRulesScheme.Label(childComplexity), true

	case "IexRulesScheme.scope":
		if e.complexity.IexRulesScheme.Scope == nil {
			break
		}

		return e.complexity.IexRulesScheme.Scope(childComplexity), true

	case "IexRulesScheme.type":
		if e.complexity.IexRulesScheme.Type == nil {
			break
		}

		return e.complexity.IexRulesScheme.Type(childComplexity), true

	case "IexRulesScheme.value":
		if e.complexity.IexRulesScheme.Value == nil {
			break
		}

		return e.complexity.IexRulesScheme.Value(childComplexity), true

	case "IexRulesScheme.weight":
		if e.complexity.IexRulesScheme.Weight == nil {
			break
		}

		return e.complexity.IexRulesScheme.Weight(childComplexity), true

	case "IexRulesScheme.weightKey":
		if e.complexity.IexRulesScheme.WeightKey == nil {
			break
		}

		return e.complexity.IexRulesScheme.WeightKey(childComplexity), true

	case "KrakenServerTime.error":
		if e.complexity.KrakenServerTime.Error == nil {
			break
		}

		return e.complexity.KrakenServerTime.Error(childComplexity), true

	case "KrakenServerTime.result":
		if e.complexity.KrakenServerTime.Result == nil {
			break
		}

		return e.complexity.KrakenServerTime.Result(childComplexity), true

	case "KrakenServerTimeResult.rfc1123":
		if e.complexity.KrakenServerTimeResult.Rfc1123 == nil {
			break
		}

		return e.complexity.KrakenServerTimeResult.Rfc1123(childComplexity), true

	case "KrakenServerTimeResult.unixtime":
		if e.complexity.KrakenServerTimeResult.Unixtime == nil {
			break
		}

		return e.complexity.KrakenServerTimeResult.Unixtime(childComplexity), true

	case "KrakenSystemStatus.error":
		if e.complexity.KrakenSystemStatus.Error == nil {
			break
		}

		return e.complexity.KrakenSystemStatus.Error(childComplexity), true

	case "KrakenSystemStatus.result":
		if e.complexity.KrakenSystemStatus.Result == nil {
			break
		}

		return e.complexity.KrakenSystemStatus.Result(childComplexity), true

	case "KrakenSystemStatusResult.status":
		if e.complexity.KrakenSystemStatusResult.Status == nil {
			break
		}

		return e.complexity.KrakenSystemStatusResult.Status(childComplexity), true

	case "KrakenSystemStatusResult.timestamp":
		if e.complexity.KrakenSystemStatusResult.Timestamp == nil {
			break
		}

		return e.complexity.KrakenSystemStatusResult.Timestamp(childComplexity), true

	case "Mutation.coinbaseConvertCurrency":
		if e.complexity.Mutation.CoinbaseConvertCurrency == nil {
			break
		}

		args, err := ec.field_Mutation_coinbaseConvertCurrency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CoinbaseConvertCurrency(childComplexity, args["opts"].(model.CoinbaseConversionsOptions)), true

	case "Mutation.coinbaseGenerateCryptoAddress":
		if e.complexity.Mutation.CoinbaseGenerateCryptoAddress == nil {
			break
		}

		args, err := ec.field_Mutation_coinbaseGenerateCryptoAddress_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CoinbaseGenerateCryptoAddress(childComplexity, args["walletId"].(string)), true

	case "Query.coinbaseAccount":
		if e.complexity.Query.CoinbaseAccount == nil {
			break
		}

		args, err := ec.field_Query_coinbaseAccount_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseAccount(childComplexity, args["accountId"].(string)), true

	case "Query.coinbaseAccountHolds":
		if e.complexity.Query.CoinbaseAccountHolds == nil {
			break
		}

		args, err := ec.field_Query_coinbaseAccountHolds_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseAccountHolds(childComplexity, args["accountId"].(string), args["opts"].(*model.CoinbaseAccountHoldsOptions)), true

	case "Query.coinbaseAccountLedger":
		if e.complexity.Query.CoinbaseAccountLedger == nil {
			break
		}

		args, err := ec.field_Query_coinbaseAccountLedger_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseAccountLedger(childComplexity, args["accountId"].(string), args["opts"].(*model.CoinbaseAccountLedgerOptions)), true

	case "Query.coinbaseAccountTransfers":
		if e.complexity.Query.CoinbaseAccountTransfers == nil {
			break
		}

		args, err := ec.field_Query_coinbaseAccountTransfers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseAccountTransfers(childComplexity, args["accountId"].(string), args["opts"].(*model.CoinbaseAccountTransferOptions)), true

	case "Query.coinbaseAccounts":
		if e.complexity.Query.CoinbaseAccounts == nil {
			break
		}

		return e.complexity.Query.CoinbaseAccounts(childComplexity), true

	case "Query.coinbaseCurrencies":
		if e.complexity.Query.CoinbaseCurrencies == nil {
			break
		}

		return e.complexity.Query.CoinbaseCurrencies(childComplexity), true

	case "Query.coinbaseCurrency":
		if e.complexity.Query.CoinbaseCurrency == nil {
			break
		}

		args, err := ec.field_Query_coinbaseCurrency_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseCurrency(childComplexity, args["currentId"].(string)), true

	case "Query.coinbaseCurrencyConversion":
		if e.complexity.Query.CoinbaseCurrencyConversion == nil {
			break
		}

		args, err := ec.field_Query_coinbaseCurrencyConversion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CoinbaseCurrencyConversion(childComplexity, args["conversionId"].(string), args["opts"].(*model.CoinbaseConversionOptions)), true

	case "Query.coinbaseWallets":
		if e.complexity.Query.CoinbaseWallets == nil {
			break
		}

		return e.complexity.Query.CoinbaseWallets(childComplexity), true

	case "Query.iexRules":
		if e.complexity.Query.IexRules == nil {
			break
		}

		args, err := ec.field_Query_iexRules_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IexRules(childComplexity, args["value"].(string)), true

	case "Query.iexRulesSchema":
		if e.complexity.Query.IexRulesSchema == nil {
			break
		}

		return e.complexity.Query.IexRulesSchema(childComplexity), true

	case "Query.krakenServerTime":
		if e.complexity.Query.KrakenServerTime == nil {
			break
		}

		return e.complexity.Query.KrakenServerTime(childComplexity), true

	case "Query.krakenSystemStatus":
		if e.complexity.Query.KrakenSystemStatus == nil {
			break
		}

		return e.complexity.Query.KrakenSystemStatus(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "graph/schema/coinbase_account.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseAccount holds data for trading account from the profile of the API key
"""
type CoinbaseAccount {
  id: String
  currency: String
  balance: Float
  available: Float
  hold: Float
  profileId: String
  tradingEnabled: Boolean
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_account_hold.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseHold represents the hold on an account that belong to the same profile
as the API key. Holds are placed on an account for any active orders or pending
withdraw requests. As an order is filled, the hold amount is updated. If an
order is canceled, any remaining hold is removed. For withdrawals, the hold is
removed after it is completed.
"""
type CoinbaseAccountHold {
  id: String
  createdAt: Time
  updatedAt: Time
  type: String
  ref: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_account_holds_options.graphqls", Input: `# * This is a generated file, do not edit

input CoinbaseAccountHoldsOptions {
  before: String
  after: String
  limit: Int
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_account_ledger.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseAccountLedger lists ledger activity for an account. This includes
anything that would affect the accounts balance - transfers, trades, fees, etc.
"""
type CoinbaseAccountLedger {
  id: String
  amount: Float
  createdAt: Time
  balance: Float
  type: EntryType
  details: CoinbaseAccountLedgerDetails
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_account_ledger_details.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseAccountLedgerDetails are the details for account history.
"""
type CoinbaseAccountLedgerDetails {
  orderId: String
  tradeId: String
  productId: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_account_ledger_options.graphqls", Input: `# * This is a generated file, do not edit

input CoinbaseAccountLedgerOptions {
  startDate: String
  endDate: String
  before: String
  after: String
  profileId: String
  limit: Int
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_account_transfer.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseAccountTransfer will lists past withdrawals and deposits for an account.
"""
type CoinbaseAccountTransfer {
  id: String
  type: String
  createdAt: Time
  completedAt: Time
  canceledAt: Time
  processedAt: Time
  amount: Float
  userNonce: String
  details: CoinbaseAccountTransferDetails
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_account_transfer_details.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseAccountTransferDetails are the details for an account transfer.
"""
type CoinbaseAccountTransferDetails {
  coinbaseAccountId: String
  coinbaseTransactionId: String
  coinbasePaymentMethodId: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_account_transfer_options.graphqls", Input: `# * This is a generated file, do not edit

input CoinbaseAccountTransferOptions {
  before: String
  after: String
  limit: Int
  type: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_account_transfers_options.graphqls", Input: `# * This is a generated file, do not edit

input CoinbaseAccountTransfersOptions {
  before: String
  after: String
  limit: Int
  type: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_bank_country.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseBankCountry are the name and code for the bank's country associated with
a wallet
"""
type CoinbaseBankCountry {
  name: String
  code: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_conversion_options.graphqls", Input: `# * This is a generated file, do not edit

input CoinbaseConversionOptions {
  profileId: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_conversions_options.graphqls", Input: `# * This is a generated file, do not edit

input CoinbaseConversionsOptions {
  profileId: String
  from: String!
  to: String!
  amount: Float!
  nonce: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_crypto_address.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseCryptoAddress is used for a one-time crypto address for depositing
crypto.
"""
type CoinbaseCryptoAddress {
  id: String
  address: String
  addressInfo: CoinbaseCryptoAddressInfo
  name: String
  createAt: Time
  updatedAt: Time
  network: String
  uriScheme: String
  resource: String
  resourcePath: String
  warnings: [CoinbaseCryptoAddressWarning]
  legacyAddress: String
  destinationTag: String
  depositUri: String
  callbackUrl: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_crypto_address_info.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseCryptoAddressInfo holds info for a crypto address
"""
type CoinbaseCryptoAddressInfo {
  address: String
  destinationTag: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_crypto_address_warning.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseCryptoAddressWarning is a warning for generating a crypting address
"""
type CoinbaseCryptoAddressWarning {
  title: String
  details: String
  imageUrl: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_currency.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseCurrency is a currency that coinbase knows about.  Not al currencies may
be currently in use for trading.
"""
type CoinbaseCurrency {
  id: String
  name: String
  minSize: Float
  status: String
  message: String
  maxPrecision: Float
  convertibleTo: [String]
  details: CoinbaseCurrencyDetails
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_currency_conversion.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseCurrencyConversion is the response that converts funds from from
currency to to currency. Funds are converted on the from account in the
profile_id profile.
"""
type CoinbaseCurrencyConversion {
  id: String
  amount: Float
  fromAccountId: String
  toAccountId: String
  from: String
  to: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_currency_details.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseCurrencyDetails are the details for a currency that coinbase knows about
"""
type CoinbaseCurrencyDetails {
  type: String
  symbol: String
  networkConfirmations: Int
  sortOrder: Int
  cryptoAddressLink: String
  cryptoTransactionLink: String
  pushPaymentMethods: [String]
  groupTypes: [String]
  displayName: String
  processingTimeSeconds: Float
  minWithdrawalAmount: Float
  maxWithdrawalAmount: Float
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_sepa_deposit_information.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseSepaDepositInformation information regarding a wallet's deposits.  A
SEPA credit transfer is a single transfer of Euros from one person or
organisation to another. For example, this could be to pay the deposit for a
holiday rental or to settle an invoice. A SEPA direct debit is a recurring
payment, for example to pay monthly rent or for a service like a mobile phone
contract.
"""
type CoinbaseSepaDepositInformation {
  iban: String
  swift: String
  bankName: String
  bankAddress: String
  bankCountry: CoinbaseBankCountry
  accountName: String
  accountAddress: String
  reference: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_swift_deposit_information.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseSwiftDepositInformation information regarding a wallet's deposits. 
SWIFT stands for Society for Worldwide Interbank Financial Telecommunications.
Basically, it's a computer network that connects over 900 banks around the world
– and enables them to transfer money. ING is part of this network. There is no
fee for accepting deposits into your account with ING.
"""
type CoinbaseSwiftDepositInformation {
  accountNumber: String
  bankName: String
  bankAddress: String
  bankCountry: CoinbaseBankCountry
  accountName: String
  accountAddress: String
  reference: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_uk_deposit_information.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseUkDepositInformation information regarding a wallet's deposits.
"""
type CoinbaseUkDepositInformation {
  accountNumber: String
  bankName: String
  bankAddress: String
  bankCountry: CoinbaseBankCountry
  accountName: String
  accountAddress: String
  reference: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_wallet.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseWallet represents a user's available Coinbase wallet (These are the
wallets/accounts that are used for buying and selling on www.coinbase.com)
"""
type CoinbaseWallet {
  id: String
  name: String
  balance: Float
  currency: String
  type: String
  primary: Boolean
  active: Boolean
  availableOnConsumer: Boolean
  ready: Boolean
  wireDepositInformation: CoinbaseWireDepositInformation
  swiftDepositInformation: CoinbaseSwiftDepositInformation
  sepaDepositInformation: CoinbaseSepaDepositInformation
  ukDepositInformation: CoinbaseUkDepositInformation
  destinationTagName: String
  destinationTagRegex: String
  holdBalance: Float
  holdCurrency: String
}
`, BuiltIn: false},
	{Name: "graph/schema/coinbase_wire_deposit_information.graphqls", Input: `# * This is a generated file, do not edit

"""
CoinbaseWireDepositInformation information regarding a wallet's deposits
"""
type CoinbaseWireDepositInformation {
  accountNumber: String
  routingNumber: String
  bankName: String
  bankAddress: String
  bankCountry: CoinbaseBankCountry
  accountName: String
  accountAddress: String
  reference: String
}
`, BuiltIn: false},
	{Name: "graph/schema/iex_rule.graphqls", Input: `# * This is a generated file, do not edit

"""
Rule to evaluate thousands of data points per second and build event-driven,
automated alerts using Rules Engine. You can access Rules Engine through the IEX
Console or through our API using the guidelines below.
"""
type IexRule {
  value: String
  label: String
  type: String
  formula: String
  scope: String
}
`, BuiltIn: false},
	{Name: "graph/schema/iex_rules_schema.graphqls", Input: `# * This is a generated file, do not edit

"""
IexRulesSchema is the latest schema for data points, notification types, and
operators used to construct rules.
"""
type IexRulesSchema {
  schema: [IexRulesScheme]
}
`, BuiltIn: false},
	{Name: "graph/schema/iex_rules_scheme.graphqls", Input: `# * This is a generated file, do not edit

"""
IEXRulesScheme is one of the latest schemes for data points, notification types,
and operators used to construct rules.
"""
type IexRulesScheme {
  label: String
  value: String
  type: String
  scope: String
  isLookup: Boolean
  weight: Float
  weightKey: String
}
`, BuiltIn: false},
	{Name: "graph/schema/kraken_server_time.graphqls", Input: `# * This is a generated file, do not edit

"""
KrakenServerTime holds data concerning the server time
"""
type KrakenServerTime {
  result: KrakenServerTimeResult
  error: [String]
}
`, BuiltIn: false},
	{Name: "graph/schema/kraken_server_time_result.graphqls", Input: `# * This is a generated file, do not edit

"""
KrakenServerTimeResult holds data concerning the server time
"""
type KrakenServerTimeResult {
  unixtime: Int
  rfc1123: Time
}
`, BuiltIn: false},
	{Name: "graph/schema/kraken_system_status.graphqls", Input: `# * This is a generated file, do not edit

"""
KrakenSystemStatus holds data concerning the current system status or trading
mode.
"""
type KrakenSystemStatus {
  result: KrakenSystemStatusResult
  error: [String]
}
`, BuiltIn: false},
	{Name: "graph/schema/kraken_system_status_result.graphqls", Input: `# * This is a generated file, do not edit

"""
KrakenSystemStatusResult holds data concerning the current system status or
trading mode.
"""
type KrakenSystemStatusResult {
  status: SystemStatus
  timestamp: Time
}
`, BuiltIn: false},
	{Name: "graph/schema/scalars.graphqls", Input: `scalar EntryType
scalar OrderCancelTime
scalar OrderSide
scalar OrderStop
scalar OrderSTP
scalar OrderType
scalar PaymentMethod
scalar SystemStatus
scalar TimeInForce
scalar Time
scalar TransferMethod
`, BuiltIn: false},
	{Name: "graph/schema/schema.graphqls", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Query {
  coinbaseAccount(accountId: String!): CoinbaseAccount
  coinbaseAccounts: [CoinbaseAccount]
  coinbaseAccountHolds(
    accountId: String!
    opts: CoinbaseAccountHoldsOptions
  ): [CoinbaseAccountHold]
  coinbaseAccountLedger(
    accountId: String!
    opts: CoinbaseAccountLedgerOptions
  ): [CoinbaseAccountLedger]
  coinbaseAccountTransfers(
    accountId: String!
    opts: CoinbaseAccountTransferOptions
  ): [CoinbaseAccountTransfer]
  coinbaseCurrencies: [CoinbaseCurrency]
  coinbaseCurrencyConversion(
    conversionId: String!
    opts: CoinbaseConversionOptions
  ): CoinbaseCurrencyConversion
  coinbaseCurrency(currentId: String!): CoinbaseCurrency
  coinbaseWallets: [CoinbaseWallet]
  iexRules(value: String!): [IexRule]
  iexRulesSchema: IexRulesSchema
  krakenServerTime: KrakenServerTime
  krakenSystemStatus: KrakenSystemStatus
}
type Mutation {
  coinbaseConvertCurrency(
    opts: CoinbaseConversionsOptions!
  ): CoinbaseCurrencyConversion
  coinbaseGenerateCryptoAddress(walletId: String!): CoinbaseCryptoAddress
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_coinbaseConvertCurrency_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.CoinbaseConversionsOptions
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		arg0, err = ec.unmarshalNCoinbaseConversionsOptions2cqlᚋmodelᚐCoinbaseConversionsOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_coinbaseGenerateCryptoAddress_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["walletId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("walletId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["walletId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseAccountHolds_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["accountId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["accountId"] = arg0
	var arg1 *model.CoinbaseAccountHoldsOptions
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		arg1, err = ec.unmarshalOCoinbaseAccountHoldsOptions2ᚖcqlᚋmodelᚐCoinbaseAccountHoldsOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["opts"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseAccountLedger_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["accountId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["accountId"] = arg0
	var arg1 *model.CoinbaseAccountLedgerOptions
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		arg1, err = ec.unmarshalOCoinbaseAccountLedgerOptions2ᚖcqlᚋmodelᚐCoinbaseAccountLedgerOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["opts"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseAccountTransfers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["accountId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["accountId"] = arg0
	var arg1 *model.CoinbaseAccountTransferOptions
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		arg1, err = ec.unmarshalOCoinbaseAccountTransferOptions2ᚖcqlᚋmodelᚐCoinbaseAccountTransferOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["opts"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseAccount_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["accountId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("accountId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["accountId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseCurrencyConversion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["conversionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["conversionId"] = arg0
	var arg1 *model.CoinbaseConversionOptions
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		arg1, err = ec.unmarshalOCoinbaseConversionOptions2ᚖcqlᚋmodelᚐCoinbaseConversionOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["opts"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_coinbaseCurrency_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["currentId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currentId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currentId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_iexRules_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["value"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["value"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _CoinbaseAccount_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccount_currency(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccount_balance(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccount_available(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Available, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccount_hold(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hold, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccount_profileId(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProfileId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccount_tradingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccount) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccount",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TradingEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountHold_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountHold) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountHold",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountHold_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountHold) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountHold",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountHold_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountHold) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountHold",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountHold_type(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountHold) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountHold",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountHold_ref(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountHold) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountHold",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedger_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedger_amount(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedger_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedger_balance(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedger_type(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedger",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(scalar.EntryType)
	fc.Result = res
	return ec.marshalOEntryType2cqlᚋscalarᚐEntryType(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedger_details(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedger) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedger",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseAccountLedgerDetails)
	fc.Result = res
	return ec.marshalOCoinbaseAccountLedgerDetails2ᚖcqlᚋmodelᚐCoinbaseAccountLedgerDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedgerDetails_orderId(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedgerDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedgerDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OrderId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedgerDetails_tradeId(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedgerDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedgerDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TradeId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountLedgerDetails_productId(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountLedgerDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountLedgerDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProductId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_type(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_createdAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_completedAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CompletedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_canceledAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanceledAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_amount(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_userNonce(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserNonce, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransfer_details(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransfer) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransfer",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseAccountTransferDetails)
	fc.Result = res
	return ec.marshalOCoinbaseAccountTransferDetails2ᚖcqlᚋmodelᚐCoinbaseAccountTransferDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransferDetails_coinbaseAccountId(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransferDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransferDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinbaseAccountId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransferDetails_coinbaseTransactionId(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransferDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransferDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinbaseTransactionId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseAccountTransferDetails_coinbasePaymentMethodId(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseAccountTransferDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseAccountTransferDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CoinbasePaymentMethodId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseBankCountry_name(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseBankCountry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseBankCountry",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseBankCountry_code(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseBankCountry) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseBankCountry",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Code, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_address(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_addressInfo(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AddressInfo(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseCryptoAddressInfo)
	fc.Result = res
	return ec.marshalOCoinbaseCryptoAddressInfo2ᚖcqlᚋmodelᚐCoinbaseCryptoAddressInfo(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_name(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_createAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_updatedAt(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_network(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Network, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_uriScheme(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UriScheme, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_resource(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Resource, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_resourcePath(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourcePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_warnings(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Warnings(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseCryptoAddressWarning)
	fc.Result = res
	return ec.marshalOCoinbaseCryptoAddressWarning2ᚕᚖcqlᚋmodelᚐCoinbaseCryptoAddressWarning(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_legacyAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LegacyAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_destinationTag(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DestinationTag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_depositUri(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DepositUri, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddress_callbackUrl(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddress) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddress",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CallbackUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddressInfo_address(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddressInfo) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddressInfo",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Address, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddressInfo_destinationTag(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddressInfo) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddressInfo",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DestinationTag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddressWarning_title(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddressWarning) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddressWarning",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddressWarning_details(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddressWarning) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddressWarning",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCryptoAddressWarning_imageUrl(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCryptoAddressWarning) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCryptoAddressWarning",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_name(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_minSize(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_status(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_message(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_maxPrecision(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxPrecision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_convertibleTo(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConvertibleTo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrency_details(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrency) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrency",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseCurrencyDetails)
	fc.Result = res
	return ec.marshalOCoinbaseCurrencyDetails2ᚖcqlᚋmodelᚐCoinbaseCurrencyDetails(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyConversion_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyConversion) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyConversion",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyConversion_amount(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyConversion) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyConversion",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyConversion_fromAccountId(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyConversion) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyConversion",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FromAccountId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyConversion_toAccountId(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyConversion) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyConversion",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ToAccountId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyConversion_from(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyConversion) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyConversion",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.From, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyConversion_to(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyConversion) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyConversion",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.To, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_type(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_symbol(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Symbol, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_networkConfirmations(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NetworkConfirmations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_sortOrder(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SortOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_cryptoAddressLink(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CryptoAddressLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_cryptoTransactionLink(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CryptoTransactionLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_pushPaymentMethods(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PushPaymentMethods, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_groupTypes(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_displayName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_processingTimeSeconds(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessingTimeSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_minWithdrawalAmount(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinWithdrawalAmount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseCurrencyDetails_maxWithdrawalAmount(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseCurrencyDetails) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseCurrencyDetails",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxWithdrawalAmount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSepaDepositInformation_iban(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSepaDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSepaDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Iban, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSepaDepositInformation_swift(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSepaDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSepaDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Swift, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSepaDepositInformation_bankName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSepaDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSepaDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSepaDepositInformation_bankAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSepaDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSepaDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSepaDepositInformation_bankCountry(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSepaDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSepaDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankCountry(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseBankCountry)
	fc.Result = res
	return ec.marshalOCoinbaseBankCountry2ᚖcqlᚋmodelᚐCoinbaseBankCountry(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSepaDepositInformation_accountName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSepaDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSepaDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSepaDepositInformation_accountAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSepaDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSepaDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSepaDepositInformation_reference(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSepaDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSepaDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reference, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSwiftDepositInformation_accountNumber(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSwiftDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSwiftDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSwiftDepositInformation_bankName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSwiftDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSwiftDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSwiftDepositInformation_bankAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSwiftDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSwiftDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSwiftDepositInformation_bankCountry(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSwiftDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSwiftDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankCountry(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseBankCountry)
	fc.Result = res
	return ec.marshalOCoinbaseBankCountry2ᚖcqlᚋmodelᚐCoinbaseBankCountry(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSwiftDepositInformation_accountName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSwiftDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSwiftDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSwiftDepositInformation_accountAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSwiftDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSwiftDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseSwiftDepositInformation_reference(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseSwiftDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseSwiftDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reference, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseUkDepositInformation_accountNumber(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseUkDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseUkDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseUkDepositInformation_bankName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseUkDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseUkDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseUkDepositInformation_bankAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseUkDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseUkDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseUkDepositInformation_bankCountry(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseUkDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseUkDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankCountry(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseBankCountry)
	fc.Result = res
	return ec.marshalOCoinbaseBankCountry2ᚖcqlᚋmodelᚐCoinbaseBankCountry(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseUkDepositInformation_accountName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseUkDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseUkDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseUkDepositInformation_accountAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseUkDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseUkDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseUkDepositInformation_reference(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseUkDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseUkDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reference, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_id(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_name(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_balance(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_currency(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Currency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_type(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_primary(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Primary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_active(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Active, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_availableOnConsumer(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailableOnConsumer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_ready(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ready, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_wireDepositInformation(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WireDepositInformation(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseWireDepositInformation)
	fc.Result = res
	return ec.marshalOCoinbaseWireDepositInformation2ᚖcqlᚋmodelᚐCoinbaseWireDepositInformation(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_swiftDepositInformation(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SwiftDepositInformation(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseSwiftDepositInformation)
	fc.Result = res
	return ec.marshalOCoinbaseSwiftDepositInformation2ᚖcqlᚋmodelᚐCoinbaseSwiftDepositInformation(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_sepaDepositInformation(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SepaDepositInformation(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseSepaDepositInformation)
	fc.Result = res
	return ec.marshalOCoinbaseSepaDepositInformation2ᚖcqlᚋmodelᚐCoinbaseSepaDepositInformation(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_ukDepositInformation(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UkDepositInformation(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseUkDepositInformation)
	fc.Result = res
	return ec.marshalOCoinbaseUkDepositInformation2ᚖcqlᚋmodelᚐCoinbaseUkDepositInformation(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_destinationTagName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DestinationTagName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_destinationTagRegex(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DestinationTagRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_holdBalance(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoldBalance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWallet_holdCurrency(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWallet) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWallet",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HoldCurrency, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_accountNumber(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_routingNumber(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoutingNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_bankName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_bankAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_bankCountry(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BankCountry(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseBankCountry)
	fc.Result = res
	return ec.marshalOCoinbaseBankCountry2ᚖcqlᚋmodelᚐCoinbaseBankCountry(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_accountName(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_accountAddress(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AccountAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _CoinbaseWireDepositInformation_reference(ctx context.Context, field graphql.CollectedField, obj *model.CoinbaseWireDepositInformation) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "CoinbaseWireDepositInformation",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reference, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _IexRule_value(ctx context.Context, field graphql.CollectedField, obj *model.IexRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "IexRule",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _IexRule_label(ctx context.Context, field graphql.CollectedField, obj *model.IexRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "IexRule",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _IexRule_type(ctx context.Context, field graphql.CollectedField, obj *model.IexRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "IexRule",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _IexRule_formula(ctx context.Context, field graphql.CollectedField, obj *model.IexRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "IexRule",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Formula, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _IexRule_scope(ctx context.Context, field graphql.CollectedField, obj *model.IexRule) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "IexRule",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _IexRulesSchema_schema(ctx context.Context, field graphql.CollectedField, obj *model.IexRulesSchema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "IexRulesSchema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Schema(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.IexRulesScheme)
	fc.Result = res
	return ec.marshalOIexRulesScheme2ᚕᚖcqlᚋmodelᚐIexRulesScheme(ctx, field.Selections, res)
}

func (ec *executionContext) _IexRulesScheme_label(ctx context.Context, field graphql.CollectedField, obj *model.IexRulesScheme) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "IexRulesScheme",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Label, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _IexRulesScheme_value(ctx context.Context, field graphql.CollectedField, obj *model.IexRulesScheme) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "IexRulesScheme",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _IexRulesScheme_type(ctx context.Context, field graphql.CollectedField, obj *model.IexRulesScheme) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "IexRulesScheme",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _IexRulesScheme_scope(ctx context.Context, field graphql.CollectedField, obj *model.IexRulesScheme) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "IexRulesScheme",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scope, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _IexRulesScheme_isLookup(ctx context.Context, field graphql.CollectedField, obj *model.IexRulesScheme) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "IexRulesScheme",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsLookup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) _IexRulesScheme_weight(ctx context.Context, field graphql.CollectedField, obj *model.IexRulesScheme) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "IexRulesScheme",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weight, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) _IexRulesScheme_weightKey(ctx context.Context, field graphql.CollectedField, obj *model.IexRulesScheme) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "IexRulesScheme",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WeightKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) _KrakenServerTime_result(ctx context.Context, field graphql.CollectedField, obj *model.KrakenServerTime) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "KrakenServerTime",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Result(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.KrakenServerTimeResult)
	fc.Result = res
	return ec.marshalOKrakenServerTimeResult2ᚖcqlᚋmodelᚐKrakenServerTimeResult(ctx, field.Selections, res)
}

func (ec *executionContext) _KrakenServerTime_error(ctx context.Context, field graphql.CollectedField, obj *model.KrakenServerTime) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "KrakenServerTime",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _KrakenServerTimeResult_unixtime(ctx context.Context, field graphql.CollectedField, obj *model.KrakenServerTimeResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "KrakenServerTimeResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Unixtime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) _KrakenServerTimeResult_rfc1123(ctx context.Context, field graphql.CollectedField, obj *model.KrakenServerTimeResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "KrakenServerTimeResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rfc1123, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _KrakenSystemStatus_result(ctx context.Context, field graphql.CollectedField, obj *model.KrakenSystemStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "KrakenSystemStatus",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Result(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.KrakenSystemStatusResult)
	fc.Result = res
	return ec.marshalOKrakenSystemStatusResult2ᚖcqlᚋmodelᚐKrakenSystemStatusResult(ctx, field.Selections, res)
}

func (ec *executionContext) _KrakenSystemStatus_error(ctx context.Context, field graphql.CollectedField, obj *model.KrakenSystemStatus) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "KrakenSystemStatus",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstring(ctx, field.Selections, res)
}

func (ec *executionContext) _KrakenSystemStatusResult_status(ctx context.Context, field graphql.CollectedField, obj *model.KrakenSystemStatusResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "KrakenSystemStatusResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(scalar.SystemStatus)
	fc.Result = res
	return ec.marshalOSystemStatus2cqlᚋscalarᚐSystemStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _KrakenSystemStatusResult_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.KrakenSystemStatusResult) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "KrakenSystemStatusResult",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_coinbaseConvertCurrency(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_coinbaseConvertCurrency_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CoinbaseConvertCurrency(rctx, args["opts"].(model.CoinbaseConversionsOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseCurrencyConversion)
	fc.Result = res
	return ec.marshalOCoinbaseCurrencyConversion2ᚖcqlᚋmodelᚐCoinbaseCurrencyConversion(ctx, field.Selections, res)
}

func (ec *executionContext) _Mutation_coinbaseGenerateCryptoAddress(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Mutation_coinbaseGenerateCryptoAddress_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CoinbaseGenerateCryptoAddress(rctx, args["walletId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseCryptoAddress)
	fc.Result = res
	return ec.marshalOCoinbaseCryptoAddress2ᚖcqlᚋmodelᚐCoinbaseCryptoAddress(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseAccount(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseAccount_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseAccount(rctx, args["accountId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseAccount)
	fc.Result = res
	return ec.marshalOCoinbaseAccount2ᚖcqlᚋmodelᚐCoinbaseAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseAccounts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseAccounts(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseAccount)
	fc.Result = res
	return ec.marshalOCoinbaseAccount2ᚕᚖcqlᚋmodelᚐCoinbaseAccount(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseAccountHolds(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseAccountHolds_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseAccountHolds(rctx, args["accountId"].(string), args["opts"].(*model.CoinbaseAccountHoldsOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseAccountHold)
	fc.Result = res
	return ec.marshalOCoinbaseAccountHold2ᚕᚖcqlᚋmodelᚐCoinbaseAccountHold(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseAccountLedger(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseAccountLedger_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseAccountLedger(rctx, args["accountId"].(string), args["opts"].(*model.CoinbaseAccountLedgerOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseAccountLedger)
	fc.Result = res
	return ec.marshalOCoinbaseAccountLedger2ᚕᚖcqlᚋmodelᚐCoinbaseAccountLedger(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseAccountTransfers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseAccountTransfers_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseAccountTransfers(rctx, args["accountId"].(string), args["opts"].(*model.CoinbaseAccountTransferOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseAccountTransfer)
	fc.Result = res
	return ec.marshalOCoinbaseAccountTransfer2ᚕᚖcqlᚋmodelᚐCoinbaseAccountTransfer(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseCurrencies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseCurrencies(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseCurrency)
	fc.Result = res
	return ec.marshalOCoinbaseCurrency2ᚕᚖcqlᚋmodelᚐCoinbaseCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseCurrencyConversion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseCurrencyConversion_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseCurrencyConversion(rctx, args["conversionId"].(string), args["opts"].(*model.CoinbaseConversionOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseCurrencyConversion)
	fc.Result = res
	return ec.marshalOCoinbaseCurrencyConversion2ᚖcqlᚋmodelᚐCoinbaseCurrencyConversion(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseCurrency(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_coinbaseCurrency_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseCurrency(rctx, args["currentId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.CoinbaseCurrency)
	fc.Result = res
	return ec.marshalOCoinbaseCurrency2ᚖcqlᚋmodelᚐCoinbaseCurrency(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_coinbaseWallets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CoinbaseWallets(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.CoinbaseWallet)
	fc.Result = res
	return ec.marshalOCoinbaseWallet2ᚕᚖcqlᚋmodelᚐCoinbaseWallet(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_iexRules(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query_iexRules_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().IexRules(rctx, args["value"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.IexRule)
	fc.Result = res
	return ec.marshalOIexRule2ᚕᚖcqlᚋmodelᚐIexRule(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_iexRulesSchema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().IexRulesSchema(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.IexRulesSchema)
	fc.Result = res
	return ec.marshalOIexRulesSchema2ᚖcqlᚋmodelᚐIexRulesSchema(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_krakenServerTime(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().KrakenServerTime(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.KrakenServerTime)
	fc.Result = res
	return ec.marshalOKrakenServerTime2ᚖcqlᚋmodelᚐKrakenServerTime(ctx, field.Selections, res)
}

func (ec *executionContext) _Query_krakenSystemStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: true,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().KrakenSystemStatus(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.KrakenSystemStatus)
	fc.Result = res
	return ec.marshalOKrakenSystemStatus2ᚖcqlᚋmodelᚐKrakenSystemStatus(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field_Query___type_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		Args:       nil,
		IsMethod:   false,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_fields_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := ec.field___Type_enumValues_args(ctx, rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	fc.Args = args
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	fc := &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		Args:       nil,
		IsMethod:   true,
		IsResolver: false,
	}

	ctx = graphql.WithFieldContext(ctx, fc)
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputCoinbaseAccountHoldsOptions(ctx context.Context, obj interface{}) (model.CoinbaseAccountHoldsOptions, error) {
	var it model.CoinbaseAccountHoldsOptions
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			it.Before, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			it.After, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			it.Limit, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCoinbaseAccountLedgerOptions(ctx context.Context, obj interface{}) (model.CoinbaseAccountLedgerOptions, error) {
	var it model.CoinbaseAccountLedgerOptions
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "startDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startDate"))
			it.StartDate, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "endDate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endDate"))
			it.EndDate, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			it.Before, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			it.After, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "profileId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("profileId"))
			it.ProfileID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			it.Limit, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCoinbaseAccountTransferOptions(ctx context.Context, obj interface{}) (model.CoinbaseAccountTransferOptions, error) {
	var it model.CoinbaseAccountTransferOptions
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			it.Before, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			it.After, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			it.Limit, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCoinbaseAccountTransfersOptions(ctx context.Context, obj interface{}) (model.CoinbaseAccountTransfersOptions, error) {
	var it model.CoinbaseAccountTransfersOptions
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			it.Before, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "after":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
			it.After, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			it.Limit, err = ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			it.Type, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCoinbaseConversionOptions(ctx context.Context, obj interface{}) (model.CoinbaseConversionOptions, error) {
	var it model.CoinbaseConversionOptions
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "profileId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("profileId"))
			it.ProfileID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCoinbaseConversionsOptions(ctx context.Context, obj interface{}) (model.CoinbaseConversionsOptions, error) {
	var it model.CoinbaseConversionsOptions
	var asMap = obj.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "profileId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("profileId"))
			it.ProfileID, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		case "from":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
			it.From, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "to":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("to"))
			it.To, err = ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
		case "amount":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amount"))
			it.Amount, err = ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
		case "nonce":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nonce"))
			it.Nonce, err = ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var coinbaseAccountImplementors = []string{"CoinbaseAccount"}

func (ec *executionContext) _CoinbaseAccount(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseAccount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseAccountImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseAccount")
		case "id":
			out.Values[i] = ec._CoinbaseAccount_id(ctx, field, obj)
		case "currency":
			out.Values[i] = ec._CoinbaseAccount_currency(ctx, field, obj)
		case "balance":
			out.Values[i] = ec._CoinbaseAccount_balance(ctx, field, obj)
		case "available":
			out.Values[i] = ec._CoinbaseAccount_available(ctx, field, obj)
		case "hold":
			out.Values[i] = ec._CoinbaseAccount_hold(ctx, field, obj)
		case "profileId":
			out.Values[i] = ec._CoinbaseAccount_profileId(ctx, field, obj)
		case "tradingEnabled":
			out.Values[i] = ec._CoinbaseAccount_tradingEnabled(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseAccountHoldImplementors = []string{"CoinbaseAccountHold"}

func (ec *executionContext) _CoinbaseAccountHold(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseAccountHold) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseAccountHoldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseAccountHold")
		case "id":
			out.Values[i] = ec._CoinbaseAccountHold_id(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._CoinbaseAccountHold_createdAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._CoinbaseAccountHold_updatedAt(ctx, field, obj)
		case "type":
			out.Values[i] = ec._CoinbaseAccountHold_type(ctx, field, obj)
		case "ref":
			out.Values[i] = ec._CoinbaseAccountHold_ref(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseAccountLedgerImplementors = []string{"CoinbaseAccountLedger"}

func (ec *executionContext) _CoinbaseAccountLedger(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseAccountLedger) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseAccountLedgerImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseAccountLedger")
		case "id":
			out.Values[i] = ec._CoinbaseAccountLedger_id(ctx, field, obj)
		case "amount":
			out.Values[i] = ec._CoinbaseAccountLedger_amount(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._CoinbaseAccountLedger_createdAt(ctx, field, obj)
		case "balance":
			out.Values[i] = ec._CoinbaseAccountLedger_balance(ctx, field, obj)
		case "type":
			out.Values[i] = ec._CoinbaseAccountLedger_type(ctx, field, obj)
		case "details":
			out.Values[i] = ec._CoinbaseAccountLedger_details(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseAccountLedgerDetailsImplementors = []string{"CoinbaseAccountLedgerDetails"}

func (ec *executionContext) _CoinbaseAccountLedgerDetails(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseAccountLedgerDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseAccountLedgerDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseAccountLedgerDetails")
		case "orderId":
			out.Values[i] = ec._CoinbaseAccountLedgerDetails_orderId(ctx, field, obj)
		case "tradeId":
			out.Values[i] = ec._CoinbaseAccountLedgerDetails_tradeId(ctx, field, obj)
		case "productId":
			out.Values[i] = ec._CoinbaseAccountLedgerDetails_productId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseAccountTransferImplementors = []string{"CoinbaseAccountTransfer"}

func (ec *executionContext) _CoinbaseAccountTransfer(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseAccountTransfer) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseAccountTransferImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseAccountTransfer")
		case "id":
			out.Values[i] = ec._CoinbaseAccountTransfer_id(ctx, field, obj)
		case "type":
			out.Values[i] = ec._CoinbaseAccountTransfer_type(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._CoinbaseAccountTransfer_createdAt(ctx, field, obj)
		case "completedAt":
			out.Values[i] = ec._CoinbaseAccountTransfer_completedAt(ctx, field, obj)
		case "canceledAt":
			out.Values[i] = ec._CoinbaseAccountTransfer_canceledAt(ctx, field, obj)
		case "processedAt":
			out.Values[i] = ec._CoinbaseAccountTransfer_processedAt(ctx, field, obj)
		case "amount":
			out.Values[i] = ec._CoinbaseAccountTransfer_amount(ctx, field, obj)
		case "userNonce":
			out.Values[i] = ec._CoinbaseAccountTransfer_userNonce(ctx, field, obj)
		case "details":
			out.Values[i] = ec._CoinbaseAccountTransfer_details(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseAccountTransferDetailsImplementors = []string{"CoinbaseAccountTransferDetails"}

func (ec *executionContext) _CoinbaseAccountTransferDetails(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseAccountTransferDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseAccountTransferDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseAccountTransferDetails")
		case "coinbaseAccountId":
			out.Values[i] = ec._CoinbaseAccountTransferDetails_coinbaseAccountId(ctx, field, obj)
		case "coinbaseTransactionId":
			out.Values[i] = ec._CoinbaseAccountTransferDetails_coinbaseTransactionId(ctx, field, obj)
		case "coinbasePaymentMethodId":
			out.Values[i] = ec._CoinbaseAccountTransferDetails_coinbasePaymentMethodId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseBankCountryImplementors = []string{"CoinbaseBankCountry"}

func (ec *executionContext) _CoinbaseBankCountry(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseBankCountry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseBankCountryImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseBankCountry")
		case "name":
			out.Values[i] = ec._CoinbaseBankCountry_name(ctx, field, obj)
		case "code":
			out.Values[i] = ec._CoinbaseBankCountry_code(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseCryptoAddressImplementors = []string{"CoinbaseCryptoAddress"}

func (ec *executionContext) _CoinbaseCryptoAddress(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseCryptoAddress) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseCryptoAddressImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseCryptoAddress")
		case "id":
			out.Values[i] = ec._CoinbaseCryptoAddress_id(ctx, field, obj)
		case "address":
			out.Values[i] = ec._CoinbaseCryptoAddress_address(ctx, field, obj)
		case "addressInfo":
			out.Values[i] = ec._CoinbaseCryptoAddress_addressInfo(ctx, field, obj)
		case "name":
			out.Values[i] = ec._CoinbaseCryptoAddress_name(ctx, field, obj)
		case "createAt":
			out.Values[i] = ec._CoinbaseCryptoAddress_createAt(ctx, field, obj)
		case "updatedAt":
			out.Values[i] = ec._CoinbaseCryptoAddress_updatedAt(ctx, field, obj)
		case "network":
			out.Values[i] = ec._CoinbaseCryptoAddress_network(ctx, field, obj)
		case "uriScheme":
			out.Values[i] = ec._CoinbaseCryptoAddress_uriScheme(ctx, field, obj)
		case "resource":
			out.Values[i] = ec._CoinbaseCryptoAddress_resource(ctx, field, obj)
		case "resourcePath":
			out.Values[i] = ec._CoinbaseCryptoAddress_resourcePath(ctx, field, obj)
		case "warnings":
			out.Values[i] = ec._CoinbaseCryptoAddress_warnings(ctx, field, obj)
		case "legacyAddress":
			out.Values[i] = ec._CoinbaseCryptoAddress_legacyAddress(ctx, field, obj)
		case "destinationTag":
			out.Values[i] = ec._CoinbaseCryptoAddress_destinationTag(ctx, field, obj)
		case "depositUri":
			out.Values[i] = ec._CoinbaseCryptoAddress_depositUri(ctx, field, obj)
		case "callbackUrl":
			out.Values[i] = ec._CoinbaseCryptoAddress_callbackUrl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseCryptoAddressInfoImplementors = []string{"CoinbaseCryptoAddressInfo"}

func (ec *executionContext) _CoinbaseCryptoAddressInfo(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseCryptoAddressInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseCryptoAddressInfoImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseCryptoAddressInfo")
		case "address":
			out.Values[i] = ec._CoinbaseCryptoAddressInfo_address(ctx, field, obj)
		case "destinationTag":
			out.Values[i] = ec._CoinbaseCryptoAddressInfo_destinationTag(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseCryptoAddressWarningImplementors = []string{"CoinbaseCryptoAddressWarning"}

func (ec *executionContext) _CoinbaseCryptoAddressWarning(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseCryptoAddressWarning) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseCryptoAddressWarningImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseCryptoAddressWarning")
		case "title":
			out.Values[i] = ec._CoinbaseCryptoAddressWarning_title(ctx, field, obj)
		case "details":
			out.Values[i] = ec._CoinbaseCryptoAddressWarning_details(ctx, field, obj)
		case "imageUrl":
			out.Values[i] = ec._CoinbaseCryptoAddressWarning_imageUrl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseCurrencyImplementors = []string{"CoinbaseCurrency"}

func (ec *executionContext) _CoinbaseCurrency(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseCurrency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseCurrencyImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseCurrency")
		case "id":
			out.Values[i] = ec._CoinbaseCurrency_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._CoinbaseCurrency_name(ctx, field, obj)
		case "minSize":
			out.Values[i] = ec._CoinbaseCurrency_minSize(ctx, field, obj)
		case "status":
			out.Values[i] = ec._CoinbaseCurrency_status(ctx, field, obj)
		case "message":
			out.Values[i] = ec._CoinbaseCurrency_message(ctx, field, obj)
		case "maxPrecision":
			out.Values[i] = ec._CoinbaseCurrency_maxPrecision(ctx, field, obj)
		case "convertibleTo":
			out.Values[i] = ec._CoinbaseCurrency_convertibleTo(ctx, field, obj)
		case "details":
			out.Values[i] = ec._CoinbaseCurrency_details(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseCurrencyConversionImplementors = []string{"CoinbaseCurrencyConversion"}

func (ec *executionContext) _CoinbaseCurrencyConversion(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseCurrencyConversion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseCurrencyConversionImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseCurrencyConversion")
		case "id":
			out.Values[i] = ec._CoinbaseCurrencyConversion_id(ctx, field, obj)
		case "amount":
			out.Values[i] = ec._CoinbaseCurrencyConversion_amount(ctx, field, obj)
		case "fromAccountId":
			out.Values[i] = ec._CoinbaseCurrencyConversion_fromAccountId(ctx, field, obj)
		case "toAccountId":
			out.Values[i] = ec._CoinbaseCurrencyConversion_toAccountId(ctx, field, obj)
		case "from":
			out.Values[i] = ec._CoinbaseCurrencyConversion_from(ctx, field, obj)
		case "to":
			out.Values[i] = ec._CoinbaseCurrencyConversion_to(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseCurrencyDetailsImplementors = []string{"CoinbaseCurrencyDetails"}

func (ec *executionContext) _CoinbaseCurrencyDetails(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseCurrencyDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseCurrencyDetailsImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseCurrencyDetails")
		case "type":
			out.Values[i] = ec._CoinbaseCurrencyDetails_type(ctx, field, obj)
		case "symbol":
			out.Values[i] = ec._CoinbaseCurrencyDetails_symbol(ctx, field, obj)
		case "networkConfirmations":
			out.Values[i] = ec._CoinbaseCurrencyDetails_networkConfirmations(ctx, field, obj)
		case "sortOrder":
			out.Values[i] = ec._CoinbaseCurrencyDetails_sortOrder(ctx, field, obj)
		case "cryptoAddressLink":
			out.Values[i] = ec._CoinbaseCurrencyDetails_cryptoAddressLink(ctx, field, obj)
		case "cryptoTransactionLink":
			out.Values[i] = ec._CoinbaseCurrencyDetails_cryptoTransactionLink(ctx, field, obj)
		case "pushPaymentMethods":
			out.Values[i] = ec._CoinbaseCurrencyDetails_pushPaymentMethods(ctx, field, obj)
		case "groupTypes":
			out.Values[i] = ec._CoinbaseCurrencyDetails_groupTypes(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._CoinbaseCurrencyDetails_displayName(ctx, field, obj)
		case "processingTimeSeconds":
			out.Values[i] = ec._CoinbaseCurrencyDetails_processingTimeSeconds(ctx, field, obj)
		case "minWithdrawalAmount":
			out.Values[i] = ec._CoinbaseCurrencyDetails_minWithdrawalAmount(ctx, field, obj)
		case "maxWithdrawalAmount":
			out.Values[i] = ec._CoinbaseCurrencyDetails_maxWithdrawalAmount(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseSepaDepositInformationImplementors = []string{"CoinbaseSepaDepositInformation"}

func (ec *executionContext) _CoinbaseSepaDepositInformation(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseSepaDepositInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseSepaDepositInformationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseSepaDepositInformation")
		case "iban":
			out.Values[i] = ec._CoinbaseSepaDepositInformation_iban(ctx, field, obj)
		case "swift":
			out.Values[i] = ec._CoinbaseSepaDepositInformation_swift(ctx, field, obj)
		case "bankName":
			out.Values[i] = ec._CoinbaseSepaDepositInformation_bankName(ctx, field, obj)
		case "bankAddress":
			out.Values[i] = ec._CoinbaseSepaDepositInformation_bankAddress(ctx, field, obj)
		case "bankCountry":
			out.Values[i] = ec._CoinbaseSepaDepositInformation_bankCountry(ctx, field, obj)
		case "accountName":
			out.Values[i] = ec._CoinbaseSepaDepositInformation_accountName(ctx, field, obj)
		case "accountAddress":
			out.Values[i] = ec._CoinbaseSepaDepositInformation_accountAddress(ctx, field, obj)
		case "reference":
			out.Values[i] = ec._CoinbaseSepaDepositInformation_reference(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseSwiftDepositInformationImplementors = []string{"CoinbaseSwiftDepositInformation"}

func (ec *executionContext) _CoinbaseSwiftDepositInformation(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseSwiftDepositInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseSwiftDepositInformationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseSwiftDepositInformation")
		case "accountNumber":
			out.Values[i] = ec._CoinbaseSwiftDepositInformation_accountNumber(ctx, field, obj)
		case "bankName":
			out.Values[i] = ec._CoinbaseSwiftDepositInformation_bankName(ctx, field, obj)
		case "bankAddress":
			out.Values[i] = ec._CoinbaseSwiftDepositInformation_bankAddress(ctx, field, obj)
		case "bankCountry":
			out.Values[i] = ec._CoinbaseSwiftDepositInformation_bankCountry(ctx, field, obj)
		case "accountName":
			out.Values[i] = ec._CoinbaseSwiftDepositInformation_accountName(ctx, field, obj)
		case "accountAddress":
			out.Values[i] = ec._CoinbaseSwiftDepositInformation_accountAddress(ctx, field, obj)
		case "reference":
			out.Values[i] = ec._CoinbaseSwiftDepositInformation_reference(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseUkDepositInformationImplementors = []string{"CoinbaseUkDepositInformation"}

func (ec *executionContext) _CoinbaseUkDepositInformation(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseUkDepositInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseUkDepositInformationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseUkDepositInformation")
		case "accountNumber":
			out.Values[i] = ec._CoinbaseUkDepositInformation_accountNumber(ctx, field, obj)
		case "bankName":
			out.Values[i] = ec._CoinbaseUkDepositInformation_bankName(ctx, field, obj)
		case "bankAddress":
			out.Values[i] = ec._CoinbaseUkDepositInformation_bankAddress(ctx, field, obj)
		case "bankCountry":
			out.Values[i] = ec._CoinbaseUkDepositInformation_bankCountry(ctx, field, obj)
		case "accountName":
			out.Values[i] = ec._CoinbaseUkDepositInformation_accountName(ctx, field, obj)
		case "accountAddress":
			out.Values[i] = ec._CoinbaseUkDepositInformation_accountAddress(ctx, field, obj)
		case "reference":
			out.Values[i] = ec._CoinbaseUkDepositInformation_reference(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseWalletImplementors = []string{"CoinbaseWallet"}

func (ec *executionContext) _CoinbaseWallet(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseWallet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseWalletImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseWallet")
		case "id":
			out.Values[i] = ec._CoinbaseWallet_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._CoinbaseWallet_name(ctx, field, obj)
		case "balance":
			out.Values[i] = ec._CoinbaseWallet_balance(ctx, field, obj)
		case "currency":
			out.Values[i] = ec._CoinbaseWallet_currency(ctx, field, obj)
		case "type":
			out.Values[i] = ec._CoinbaseWallet_type(ctx, field, obj)
		case "primary":
			out.Values[i] = ec._CoinbaseWallet_primary(ctx, field, obj)
		case "active":
			out.Values[i] = ec._CoinbaseWallet_active(ctx, field, obj)
		case "availableOnConsumer":
			out.Values[i] = ec._CoinbaseWallet_availableOnConsumer(ctx, field, obj)
		case "ready":
			out.Values[i] = ec._CoinbaseWallet_ready(ctx, field, obj)
		case "wireDepositInformation":
			out.Values[i] = ec._CoinbaseWallet_wireDepositInformation(ctx, field, obj)
		case "swiftDepositInformation":
			out.Values[i] = ec._CoinbaseWallet_swiftDepositInformation(ctx, field, obj)
		case "sepaDepositInformation":
			out.Values[i] = ec._CoinbaseWallet_sepaDepositInformation(ctx, field, obj)
		case "ukDepositInformation":
			out.Values[i] = ec._CoinbaseWallet_ukDepositInformation(ctx, field, obj)
		case "destinationTagName":
			out.Values[i] = ec._CoinbaseWallet_destinationTagName(ctx, field, obj)
		case "destinationTagRegex":
			out.Values[i] = ec._CoinbaseWallet_destinationTagRegex(ctx, field, obj)
		case "holdBalance":
			out.Values[i] = ec._CoinbaseWallet_holdBalance(ctx, field, obj)
		case "holdCurrency":
			out.Values[i] = ec._CoinbaseWallet_holdCurrency(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var coinbaseWireDepositInformationImplementors = []string{"CoinbaseWireDepositInformation"}

func (ec *executionContext) _CoinbaseWireDepositInformation(ctx context.Context, sel ast.SelectionSet, obj *model.CoinbaseWireDepositInformation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, coinbaseWireDepositInformationImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CoinbaseWireDepositInformation")
		case "accountNumber":
			out.Values[i] = ec._CoinbaseWireDepositInformation_accountNumber(ctx, field, obj)
		case "routingNumber":
			out.Values[i] = ec._CoinbaseWireDepositInformation_routingNumber(ctx, field, obj)
		case "bankName":
			out.Values[i] = ec._CoinbaseWireDepositInformation_bankName(ctx, field, obj)
		case "bankAddress":
			out.Values[i] = ec._CoinbaseWireDepositInformation_bankAddress(ctx, field, obj)
		case "bankCountry":
			out.Values[i] = ec._CoinbaseWireDepositInformation_bankCountry(ctx, field, obj)
		case "accountName":
			out.Values[i] = ec._CoinbaseWireDepositInformation_accountName(ctx, field, obj)
		case "accountAddress":
			out.Values[i] = ec._CoinbaseWireDepositInformation_accountAddress(ctx, field, obj)
		case "reference":
			out.Values[i] = ec._CoinbaseWireDepositInformation_reference(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var iexRuleImplementors = []string{"IexRule"}

func (ec *executionContext) _IexRule(ctx context.Context, sel ast.SelectionSet, obj *model.IexRule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iexRuleImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IexRule")
		case "value":
			out.Values[i] = ec._IexRule_value(ctx, field, obj)
		case "label":
			out.Values[i] = ec._IexRule_label(ctx, field, obj)
		case "type":
			out.Values[i] = ec._IexRule_type(ctx, field, obj)
		case "formula":
			out.Values[i] = ec._IexRule_formula(ctx, field, obj)
		case "scope":
			out.Values[i] = ec._IexRule_scope(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var iexRulesSchemaImplementors = []string{"IexRulesSchema"}

func (ec *executionContext) _IexRulesSchema(ctx context.Context, sel ast.SelectionSet, obj *model.IexRulesSchema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iexRulesSchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IexRulesSchema")
		case "schema":
			out.Values[i] = ec._IexRulesSchema_schema(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var iexRulesSchemeImplementors = []string{"IexRulesScheme"}

func (ec *executionContext) _IexRulesScheme(ctx context.Context, sel ast.SelectionSet, obj *model.IexRulesScheme) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iexRulesSchemeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IexRulesScheme")
		case "label":
			out.Values[i] = ec._IexRulesScheme_label(ctx, field, obj)
		case "value":
			out.Values[i] = ec._IexRulesScheme_value(ctx, field, obj)
		case "type":
			out.Values[i] = ec._IexRulesScheme_type(ctx, field, obj)
		case "scope":
			out.Values[i] = ec._IexRulesScheme_scope(ctx, field, obj)
		case "isLookup":
			out.Values[i] = ec._IexRulesScheme_isLookup(ctx, field, obj)
		case "weight":
			out.Values[i] = ec._IexRulesScheme_weight(ctx, field, obj)
		case "weightKey":
			out.Values[i] = ec._IexRulesScheme_weightKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var krakenServerTimeImplementors = []string{"KrakenServerTime"}

func (ec *executionContext) _KrakenServerTime(ctx context.Context, sel ast.SelectionSet, obj *model.KrakenServerTime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, krakenServerTimeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KrakenServerTime")
		case "result":
			out.Values[i] = ec._KrakenServerTime_result(ctx, field, obj)
		case "error":
			out.Values[i] = ec._KrakenServerTime_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var krakenServerTimeResultImplementors = []string{"KrakenServerTimeResult"}

func (ec *executionContext) _KrakenServerTimeResult(ctx context.Context, sel ast.SelectionSet, obj *model.KrakenServerTimeResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, krakenServerTimeResultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KrakenServerTimeResult")
		case "unixtime":
			out.Values[i] = ec._KrakenServerTimeResult_unixtime(ctx, field, obj)
		case "rfc1123":
			out.Values[i] = ec._KrakenServerTimeResult_rfc1123(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var krakenSystemStatusImplementors = []string{"KrakenSystemStatus"}

func (ec *executionContext) _KrakenSystemStatus(ctx context.Context, sel ast.SelectionSet, obj *model.KrakenSystemStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, krakenSystemStatusImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KrakenSystemStatus")
		case "result":
			out.Values[i] = ec._KrakenSystemStatus_result(ctx, field, obj)
		case "error":
			out.Values[i] = ec._KrakenSystemStatus_error(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var krakenSystemStatusResultImplementors = []string{"KrakenSystemStatusResult"}

func (ec *executionContext) _KrakenSystemStatusResult(ctx context.Context, sel ast.SelectionSet, obj *model.KrakenSystemStatusResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, krakenSystemStatusResultImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KrakenSystemStatusResult")
		case "status":
			out.Values[i] = ec._KrakenSystemStatusResult_status(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._KrakenSystemStatusResult_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "coinbaseConvertCurrency":
			out.Values[i] = ec._Mutation_coinbaseConvertCurrency(ctx, field)
		case "coinbaseGenerateCryptoAddress":
			out.Values[i] = ec._Mutation_coinbaseGenerateCryptoAddress(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)

	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "coinbaseAccount":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseAccount(ctx, field)
				return res
			})
		case "coinbaseAccounts":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseAccounts(ctx, field)
				return res
			})
		case "coinbaseAccountHolds":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseAccountHolds(ctx, field)
				return res
			})
		case "coinbaseAccountLedger":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseAccountLedger(ctx, field)
				return res
			})
		case "coinbaseAccountTransfers":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseAccountTransfers(ctx, field)
				return res
			})
		case "coinbaseCurrencies":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseCurrencies(ctx, field)
				return res
			})
		case "coinbaseCurrencyConversion":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseCurrencyConversion(ctx, field)
				return res
			})
		case "coinbaseCurrency":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseCurrency(ctx, field)
				return res
			})
		case "coinbaseWallets":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_coinbaseWallets(ctx, field)
				return res
			})
		case "iexRules":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_iexRules(ctx, field)
				return res
			})
		case "iexRulesSchema":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_iexRulesSchema(ctx, field)
				return res
			})
		case "krakenServerTime":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_krakenServerTime(ctx, field)
				return res
			})
		case "krakenSystemStatus":
			field := field
			out.Concurrently(i, func() (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_krakenSystemStatus(ctx, field)
				return res
			})
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNCoinbaseConversionsOptions2cqlᚋmodelᚐCoinbaseConversionsOptions(ctx context.Context, v interface{}) (model.CoinbaseConversionsOptions, error) {
	res, err := ec.unmarshalInputCoinbaseConversionsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloat(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "must not be null")
		}
	}
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	return graphql.MarshalBoolean(v)
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalBoolean(*v)
}

func (ec *executionContext) marshalOCoinbaseAccount2ᚕᚖcqlᚋmodelᚐCoinbaseAccount(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseAccount2ᚖcqlᚋmodelᚐCoinbaseAccount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseAccount2ᚖcqlᚋmodelᚐCoinbaseAccount(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseAccount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseAccount(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseAccountHold2ᚕᚖcqlᚋmodelᚐCoinbaseAccountHold(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseAccountHold) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseAccountHold2ᚖcqlᚋmodelᚐCoinbaseAccountHold(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseAccountHold2ᚖcqlᚋmodelᚐCoinbaseAccountHold(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseAccountHold) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseAccountHold(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCoinbaseAccountHoldsOptions2ᚖcqlᚋmodelᚐCoinbaseAccountHoldsOptions(ctx context.Context, v interface{}) (*model.CoinbaseAccountHoldsOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCoinbaseAccountHoldsOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCoinbaseAccountLedger2ᚕᚖcqlᚋmodelᚐCoinbaseAccountLedger(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseAccountLedger) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseAccountLedger2ᚖcqlᚋmodelᚐCoinbaseAccountLedger(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseAccountLedger2ᚖcqlᚋmodelᚐCoinbaseAccountLedger(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseAccountLedger) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseAccountLedger(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseAccountLedgerDetails2ᚖcqlᚋmodelᚐCoinbaseAccountLedgerDetails(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseAccountLedgerDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseAccountLedgerDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCoinbaseAccountLedgerOptions2ᚖcqlᚋmodelᚐCoinbaseAccountLedgerOptions(ctx context.Context, v interface{}) (*model.CoinbaseAccountLedgerOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCoinbaseAccountLedgerOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCoinbaseAccountTransfer2ᚕᚖcqlᚋmodelᚐCoinbaseAccountTransfer(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseAccountTransfer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseAccountTransfer2ᚖcqlᚋmodelᚐCoinbaseAccountTransfer(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseAccountTransfer2ᚖcqlᚋmodelᚐCoinbaseAccountTransfer(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseAccountTransfer) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseAccountTransfer(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseAccountTransferDetails2ᚖcqlᚋmodelᚐCoinbaseAccountTransferDetails(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseAccountTransferDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseAccountTransferDetails(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCoinbaseAccountTransferOptions2ᚖcqlᚋmodelᚐCoinbaseAccountTransferOptions(ctx context.Context, v interface{}) (*model.CoinbaseAccountTransferOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCoinbaseAccountTransferOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCoinbaseBankCountry2ᚖcqlᚋmodelᚐCoinbaseBankCountry(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseBankCountry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseBankCountry(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCoinbaseConversionOptions2ᚖcqlᚋmodelᚐCoinbaseConversionOptions(ctx context.Context, v interface{}) (*model.CoinbaseConversionOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCoinbaseConversionOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCoinbaseCryptoAddress2ᚖcqlᚋmodelᚐCoinbaseCryptoAddress(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseCryptoAddress) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseCryptoAddress(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseCryptoAddressInfo2ᚖcqlᚋmodelᚐCoinbaseCryptoAddressInfo(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseCryptoAddressInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseCryptoAddressInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseCryptoAddressWarning2ᚕᚖcqlᚋmodelᚐCoinbaseCryptoAddressWarning(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseCryptoAddressWarning) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseCryptoAddressWarning2ᚖcqlᚋmodelᚐCoinbaseCryptoAddressWarning(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseCryptoAddressWarning2ᚖcqlᚋmodelᚐCoinbaseCryptoAddressWarning(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseCryptoAddressWarning) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseCryptoAddressWarning(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseCurrency2ᚕᚖcqlᚋmodelᚐCoinbaseCurrency(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseCurrency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseCurrency2ᚖcqlᚋmodelᚐCoinbaseCurrency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseCurrency2ᚖcqlᚋmodelᚐCoinbaseCurrency(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseCurrency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseCurrency(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseCurrencyConversion2ᚖcqlᚋmodelᚐCoinbaseCurrencyConversion(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseCurrencyConversion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseCurrencyConversion(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseCurrencyDetails2ᚖcqlᚋmodelᚐCoinbaseCurrencyDetails(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseCurrencyDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseCurrencyDetails(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseSepaDepositInformation2ᚖcqlᚋmodelᚐCoinbaseSepaDepositInformation(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseSepaDepositInformation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseSepaDepositInformation(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseSwiftDepositInformation2ᚖcqlᚋmodelᚐCoinbaseSwiftDepositInformation(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseSwiftDepositInformation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseSwiftDepositInformation(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseUkDepositInformation2ᚖcqlᚋmodelᚐCoinbaseUkDepositInformation(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseUkDepositInformation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseUkDepositInformation(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseWallet2ᚕᚖcqlᚋmodelᚐCoinbaseWallet(ctx context.Context, sel ast.SelectionSet, v []*model.CoinbaseWallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOCoinbaseWallet2ᚖcqlᚋmodelᚐCoinbaseWallet(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOCoinbaseWallet2ᚖcqlᚋmodelᚐCoinbaseWallet(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseWallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseWallet(ctx, sel, v)
}

func (ec *executionContext) marshalOCoinbaseWireDepositInformation2ᚖcqlᚋmodelᚐCoinbaseWireDepositInformation(ctx context.Context, sel ast.SelectionSet, v *model.CoinbaseWireDepositInformation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CoinbaseWireDepositInformation(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEntryType2cqlᚋscalarᚐEntryType(ctx context.Context, v interface{}) (scalar.EntryType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := scalar.EntryType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOEntryType2cqlᚋscalarᚐEntryType(ctx context.Context, sel ast.SelectionSet, v scalar.EntryType) graphql.Marshaler {
	return graphql.MarshalString(string(v))
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloat(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	return graphql.MarshalFloat(v)
}

func (ec *executionContext) marshalOIexRule2ᚕᚖcqlᚋmodelᚐIexRule(ctx context.Context, sel ast.SelectionSet, v []*model.IexRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOIexRule2ᚖcqlᚋmodelᚐIexRule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOIexRule2ᚖcqlᚋmodelᚐIexRule(ctx context.Context, sel ast.SelectionSet, v *model.IexRule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IexRule(ctx, sel, v)
}

func (ec *executionContext) marshalOIexRulesSchema2ᚖcqlᚋmodelᚐIexRulesSchema(ctx context.Context, sel ast.SelectionSet, v *model.IexRulesSchema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IexRulesSchema(ctx, sel, v)
}

func (ec *executionContext) marshalOIexRulesScheme2ᚕᚖcqlᚋmodelᚐIexRulesScheme(ctx context.Context, sel ast.SelectionSet, v []*model.IexRulesScheme) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOIexRulesScheme2ᚖcqlᚋmodelᚐIexRulesScheme(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalOIexRulesScheme2ᚖcqlᚋmodelᚐIexRulesScheme(ctx context.Context, sel ast.SelectionSet, v *model.IexRulesScheme) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._IexRulesScheme(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	return graphql.MarshalInt(v)
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalInt(*v)
}

func (ec *executionContext) marshalOKrakenServerTime2ᚖcqlᚋmodelᚐKrakenServerTime(ctx context.Context, sel ast.SelectionSet, v *model.KrakenServerTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KrakenServerTime(ctx, sel, v)
}

func (ec *executionContext) marshalOKrakenServerTimeResult2ᚖcqlᚋmodelᚐKrakenServerTimeResult(ctx context.Context, sel ast.SelectionSet, v *model.KrakenServerTimeResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KrakenServerTimeResult(ctx, sel, v)
}

func (ec *executionContext) marshalOKrakenSystemStatus2ᚖcqlᚋmodelᚐKrakenSystemStatus(ctx context.Context, sel ast.SelectionSet, v *model.KrakenSystemStatus) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KrakenSystemStatus(ctx, sel, v)
}

func (ec *executionContext) marshalOKrakenSystemStatusResult2ᚖcqlᚋmodelᚐKrakenSystemStatusResult(ctx context.Context, sel ast.SelectionSet, v *model.KrakenSystemStatusResult) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KrakenSystemStatusResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	return graphql.MarshalString(v)
}

func (ec *executionContext) unmarshalOString2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		if tmp1, ok := v.([]interface{}); ok {
			vSlice = tmp1
		} else {
			vSlice = []interface{}{v}
		}
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*v)
}

func (ec *executionContext) unmarshalOSystemStatus2cqlᚋscalarᚐSystemStatus(ctx context.Context, v interface{}) (scalar.SystemStatus, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := scalar.SystemStatus(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSystemStatus2cqlᚋscalarᚐSystemStatus(ctx context.Context, sel ast.SelectionSet, v scalar.SystemStatus) graphql.Marshaler {
	return graphql.MarshalString(string(v))
}

func (ec *executionContext) unmarshalOTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	return graphql.MarshalTime(v)
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()
	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
