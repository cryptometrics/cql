package coinbase

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/cryptometrics/cql/env"

	"github.com/cryptometrics/cql/client"

	"github.com/sirupsen/logrus"
)

// proC is the coinbase pro client
type proC struct {
	client     http.Client
	key        string
	passphrase string
	secret     string
	url        string
}

// newCoinbaseProClient will populate the client auth credietions directly
func newCoinbaseProClient(key, passphrase, secret, url string) *proC {
	c := new(proC)
	c.key = key
	c.passphrase = passphrase
	c.secret = secret
	c.url = url
	return c
}

// newCoinbaseProClientEnv will populate the client auth credentials using a
// .env file
func newCoinbaseProClientEnv(filepath string) *proC {
	c := new(proC)
	env.Load(filepath)
	c.key = env.CoinbaseProAccessKey.Get()
	c.passphrase = env.CoinbaseProAccessPassphrase.Get()
	c.secret = env.CoinbaseProSecret.Get()
	c.url = env.CoinbaseProURL.Get()
	return c
}

// generateSig generates the coinbase base64-encoded signature required to make
// requests.  In particular, the CB-ACCESS-SIGN header is generated by creating
// a sha256 HMAC using the base64-decoded secret key on the prehash string
// timestamp + method + requestPath + body (where + represents string
// concatenation) and base64-encode the output. The timestamp value is the same
// as the CB-ACCESS-TIMESTAMP header.
func (cb *proC) generateSig(secret, message string) (string, error) {
	key, err := base64.StdEncoding.DecodeString(secret)
	if err != nil {
		return "", err
	}

	signature := hmac.New(sha256.New, key)
	_, err = signature.Write([]byte(message))
	if err != nil {
		return "", err
	}

	return base64.StdEncoding.EncodeToString(signature.Sum(nil)), nil
}

// generageMsg makes the message to be signed
func (cb *proC) generageMsg(creq client.Request, timestamp string) string {
	return fmt.Sprintf("%s%s%s%s", timestamp, creq.MethodStr(), creq.EndpointPath(), string(creq.GetBody().Bytes()))
}

// setHeaders sets the headers for a coinbase api request, in particular:
//
// - CB-ACCESS-KEY The api key as a string.
// - CB-ACCESS-SIGN The base64-encoded signature (see Signing a Message).
// - CB-ACCESS-TIMESTAMP A timestamp for your request.
// - CB-ACCESS-PASSPHRASE The passphrase you specified when creating the API key.
func (cb *proC) setHeaders(hreq *http.Request, creq client.Request) (e error) {
	// TODO depricate getting key/passphrase/secret with secret keeper
	var (
		timestamp = strconv.FormatInt(time.Now().Unix(), 10)
		msg       = cb.generageMsg(creq, timestamp)
	)

	var sig string
	sig, e = cb.generateSig(cb.secret, msg)
	hreq.Header.Add("accept", "application/json")
	hreq.Header.Add("content-type", "application/json")
	hreq.Header.Add("cb-access-key", cb.key)
	hreq.Header.Add("cb-access-passphrase", cb.passphrase)
	hreq.Header.Add("cb-access-sign", sig)
	hreq.Header.Add("cb-access-timestamp", timestamp)

	logMsg := `{Client:{Access:{Key:%s,Passphrase:%s,Timestamp:%s,Sign:%s}}}`
	logrus.Debug(client.Logf(&creq, logMsg, cb.key, cb.passphrase, timestamp, sig))
	return
}

// request makes an http request to the coinbase api, given a method and an
// endpoint.
//
// TODO make data-compatible for non-get requests
func (cb *proC) Do(creq client.Request) (*http.Response, error) {
	uri := cb.url + creq.EndpointPath()

	logrus.Debug(client.Logf(&creq, `{Client:{URI:%s}}`, uri))

	hreq, err := http.NewRequest(creq.MethodStr(), uri, bytes.NewReader(creq.GetBody().Bytes()))
	if err != nil {
		return nil, err
	}
	if err := cb.setHeaders(hreq, creq); err != nil {
		return nil, err
	}
	return cb.client.Do(hreq)
}

// Connect creats a new client instance
func (cb *proC) Connect() error {
	cb.client = http.Client{}
	return nil
}

// Identifier identifies requests
func (cb *proC) Identifier() string {
	return "Coinbase Pro"
}

// newClient returns a new client interface.  This method is what we call a
// "connector"
func newClient() (client.C, error) {
	return &proC{}, nil
}

// DefaultClient will pull the coinbase authentication data from the env
// variables.  See README for more information on how to set these up.
func DefaultClient() (client.C, error) {
	c := newCoinbaseProClientEnv("../../.auth.env")
	return c, nil
}

// NewClient will populate the coinbase auth data from args
func NewClient(url, key, passphrase, secret string) (client.C, error) {
	return newCoinbaseProClient(key, passphrase, secret, url), nil
}

// NewClient will populate the coinbase auth data from a .env file
func NewClientEnv(filepath string) (client.C, error) {
	return newCoinbaseProClientEnv(filepath), nil
}
