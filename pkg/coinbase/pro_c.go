package coinbase

import (
	"bytes"
	"crypto/hmac"
	"crypto/sha256"
	"cryptometrics/cql/client"
	"cryptometrics/cql/env"
	"encoding/base64"
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/sirupsen/logrus"
)

// proC is the coinbase pro client
type proC struct {
	client http.Client
}

// generateSig generates the coinbase base64-encoded signature required to make
// requests.  In particular, the CB-ACCESS-SIGN header is generated by creating
// a sha256 HMAC using the base64-decoded secret key on the prehash string
// timestamp + method + requestPath + body (where + represents string
// concatenation) and base64-encode the output. The timestamp value is the same
// as the CB-ACCESS-TIMESTAMP header.
func (cb *proC) generateSig(secret, message string) (string, error) {
	key, err := base64.StdEncoding.DecodeString(secret)
	if err != nil {
		return "", err
	}

	signature := hmac.New(sha256.New, key)
	_, err = signature.Write([]byte(message))
	if err != nil {
		return "", err
	}

	return base64.StdEncoding.EncodeToString(signature.Sum(nil)), nil
}

// generageMsg makes the message to be signed
func (cb *proC) generageMsg(creq client.Request, timestamp string) string {
	return fmt.Sprintf("%s%s%s%s", timestamp, creq.MethodStr(), creq.EndpointPath(), string(creq.GetBody().Bytes()))
}

// setHeaders sets the headers for a coinbase api request, in particular:
//
// - CB-ACCESS-KEY The api key as a string.
// - CB-ACCESS-SIGN The base64-encoded signature (see Signing a Message).
// - CB-ACCESS-TIMESTAMP A timestamp for your request.
// - CB-ACCESS-PASSPHRASE The passphrase you specified when creating the API key.
func (cb *proC) setHeaders(hreq *http.Request, creq client.Request) (e error) {
	// TODO depricate getting key/passphrase/secret with secret keeper
	var (
		key        = env.CoinbaseProAccessKey.Get()
		passphrase = env.CoinbaseProAccessPassphrase.Get()
		secret     = env.CoinbaseProSecret.Get()
		timestamp  = strconv.FormatInt(time.Now().Unix(), 10)
		msg        = cb.generageMsg(creq, timestamp)
	)
	var sig string
	sig, e = cb.generateSig(secret, msg)
	hreq.Header.Add("accept", "application/json")
	hreq.Header.Add("content-type", "application/json")
	// hreq.Header.Add("User-Agent", "Go coinbase Pro Client 1.0")
	hreq.Header.Add("cb-access-key", key)
	hreq.Header.Add("cb-access-passphrase", passphrase)
	hreq.Header.Add("cb-access-sign", sig)
	hreq.Header.Add("cb-access-timestamp", timestamp)

	logMsg := `{Client:{Access:{Key:%s,Passphrase:%s,Timestamp:%s,Sign:%s}}}`
	logrus.Debug(client.Logf(&creq, logMsg, key, passphrase, timestamp, sig))
	return
}

// request makes an http request to the coinbase api, given a method and an
// endpoint.
//
// TODO make data-compatible for non-get requests
func (cb *proC) Do(creq client.Request) (*http.Response, error) {
	uri := env.CoinbaseProURL.Get() + creq.EndpointPath()

	logrus.Debug(client.Logf(&creq, `{Client:{URI:%s}}`, uri))

	hreq, err := http.NewRequest(creq.MethodStr(), uri, bytes.NewReader(creq.GetBody().Bytes()))
	if err != nil {
		return nil, err
	}
	if err := cb.setHeaders(hreq, creq); err != nil {
		return nil, err
	}
	return cb.client.Do(hreq)
}

// Connect creats a new client instance
func (cb *proC) Connect() error {
	cb.client = http.Client{}
	return nil
}

// Identifier identifies requests
func (cb *proC) Identifier() string {
	return "Coinbase Pro"
}

// newClient returns a new client interface.  This method is what we call a
// "connector"
func newClient() (client.C, error) {
	return &proC{}, nil
}

// DefaultClient will pull the coinbase authentication data from the env
// variables.  See README for more information on how to set these up.
func DefaultClient() (client.C, error) {
	return &proC{}, nil
}
